/*
Mist API

> Version: **2406.1.14** > > Date: **July 3, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.14
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"os"
)


type SitesDevicesAPI interface {

	/*
	AddSiteDeviceImage addSiteDeviceImage

	Attach up to 3 images to a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@param imageNumber
	@return ApiAddSiteDeviceImageRequest
	*/
	AddSiteDeviceImage(ctx context.Context, siteId string, deviceId string, imageNumber int32) ApiAddSiteDeviceImageRequest

	// AddSiteDeviceImageExecute executes the request
	AddSiteDeviceImageExecute(r ApiAddSiteDeviceImageRequest) (*http.Response, error)

	/*
	CountSiteDeviceConfigHistory countSiteDeviceConfigHistory

	Counts the number of entries in device config history for distinct field with given filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteDeviceConfigHistoryRequest
	*/
	CountSiteDeviceConfigHistory(ctx context.Context, siteId string) ApiCountSiteDeviceConfigHistoryRequest

	// CountSiteDeviceConfigHistoryExecute executes the request
	//  @return RepsonseCount
	CountSiteDeviceConfigHistoryExecute(r ApiCountSiteDeviceConfigHistoryRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountSiteDeviceEvents countSiteDeviceEvents

	Counts the number of entries in ap events history for distinct field with given filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteDeviceEventsRequest
	*/
	CountSiteDeviceEvents(ctx context.Context, siteId string) ApiCountSiteDeviceEventsRequest

	// CountSiteDeviceEventsExecute executes the request
	//  @return RepsonseCount
	CountSiteDeviceEventsExecute(r ApiCountSiteDeviceEventsRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountSiteDeviceLastConfig countSiteDeviceLastConfig

	Counts the number of entries in device config history for distinct field with given filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteDeviceLastConfigRequest
	*/
	CountSiteDeviceLastConfig(ctx context.Context, siteId string) ApiCountSiteDeviceLastConfigRequest

	// CountSiteDeviceLastConfigExecute executes the request
	//  @return RepsonseCount
	CountSiteDeviceLastConfigExecute(r ApiCountSiteDeviceLastConfigRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountSiteDevices countSiteDevices

	Counts the number of entries in ap events history for distinct field with given filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteDevicesRequest
	*/
	CountSiteDevices(ctx context.Context, siteId string) ApiCountSiteDevicesRequest

	// CountSiteDevicesExecute executes the request
	//  @return RepsonseCount
	CountSiteDevicesExecute(r ApiCountSiteDevicesRequest) (*RepsonseCount, *http.Response, error)

	/*
	DeleteSiteDevice deleteSiteDevice

	Delete Site Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@return ApiDeleteSiteDeviceRequest
	*/
	DeleteSiteDevice(ctx context.Context, siteId string, deviceId string) ApiDeleteSiteDeviceRequest

	// DeleteSiteDeviceExecute executes the request
	DeleteSiteDeviceExecute(r ApiDeleteSiteDeviceRequest) (*http.Response, error)

	/*
	DeleteSiteDeviceImage deleteSiteDeviceImage

	Delete image from a device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@param imageNumber
	@return ApiDeleteSiteDeviceImageRequest
	*/
	DeleteSiteDeviceImage(ctx context.Context, siteId string, deviceId string, imageNumber int32) ApiDeleteSiteDeviceImageRequest

	// DeleteSiteDeviceImageExecute executes the request
	DeleteSiteDeviceImageExecute(r ApiDeleteSiteDeviceImageRequest) (*http.Response, error)

	/*
	ExportSiteDevices exportSiteDevices

	To download the exported device information

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiExportSiteDevicesRequest
	*/
	ExportSiteDevices(ctx context.Context, siteId string) ApiExportSiteDevicesRequest

	// ExportSiteDevicesExecute executes the request
	//  @return *os.File
	ExportSiteDevicesExecute(r ApiExportSiteDevicesRequest) (*os.File, *http.Response, error)

	/*
	GetSiteDevice getSiteDevice

	Get Device Configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@return ApiGetSiteDeviceRequest
	*/
	GetSiteDevice(ctx context.Context, siteId string, deviceId string) ApiGetSiteDeviceRequest

	// GetSiteDeviceExecute executes the request
	//  @return ResponseDevice
	GetSiteDeviceExecute(r ApiGetSiteDeviceRequest) (*ResponseDevice, *http.Response, error)

	/*
	ImportSiteDevices importSiteDevices

	Import Information for Multiple Devices

CSV format:
```csv
mac,name,map_id,x,y,height,orientation,labels,band_24.power,band_24.bandwidth,band_24.channel,band_24.disabled,band_5.power,band_5.bandwidth,band_5.channel,band_5.disabled,band_6.power,band_6.bandwidth,band_6.channel,band_6.disabled
5c5b53010101,"AP 1",845a23bf-bed9-e43c-4c86-6fa474be7ae5,30,10,2.3,45,"guest, campus, vip",1,20,0,false,0,40,0,false,17,80,0,false
```

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiImportSiteDevicesRequest
	*/
	ImportSiteDevices(ctx context.Context, siteId string) ApiImportSiteDevicesRequest

	// ImportSiteDevicesExecute executes the request
	//  @return []ConfigDevice
	ImportSiteDevicesExecute(r ApiImportSiteDevicesRequest) ([]ConfigDevice, *http.Response, error)

	/*
	ListSiteDevices listSiteDevices

	Get list of devices on the site.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiListSiteDevicesRequest
	*/
	ListSiteDevices(ctx context.Context, siteId string) ApiListSiteDevicesRequest

	// ListSiteDevicesExecute executes the request
	//  @return []ConfigDevice
	ListSiteDevicesExecute(r ApiListSiteDevicesRequest) ([]ConfigDevice, *http.Response, error)

	/*
	RestartSiteMultipleDevices restartSiteMultipleDevices

	Note that only the devices that are connected will be restarted.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiRestartSiteMultipleDevicesRequest
	*/
	RestartSiteMultipleDevices(ctx context.Context, siteId string) ApiRestartSiteMultipleDevicesRequest

	// RestartSiteMultipleDevicesExecute executes the request
	RestartSiteMultipleDevicesExecute(r ApiRestartSiteMultipleDevicesRequest) (*http.Response, error)

	/*
	SearchSiteDeviceConfigHistory searchSiteDeviceConfigHistory

	Search for entries in device config history

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteDeviceConfigHistoryRequest
	*/
	SearchSiteDeviceConfigHistory(ctx context.Context, siteId string) ApiSearchSiteDeviceConfigHistoryRequest

	// SearchSiteDeviceConfigHistoryExecute executes the request
	//  @return ResponseConfigHistorySearch
	SearchSiteDeviceConfigHistoryExecute(r ApiSearchSiteDeviceConfigHistoryRequest) (*ResponseConfigHistorySearch, *http.Response, error)

	/*
	SearchSiteDeviceEvents searchSiteDeviceEvents

	Search Devices Events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteDeviceEventsRequest
	*/
	SearchSiteDeviceEvents(ctx context.Context, siteId string) ApiSearchSiteDeviceEventsRequest

	// SearchSiteDeviceEventsExecute executes the request
	//  @return ResponseEventsDevices
	SearchSiteDeviceEventsExecute(r ApiSearchSiteDeviceEventsRequest) (*ResponseEventsDevices, *http.Response, error)

	/*
	SearchSiteDeviceLastConfigs searchSiteDeviceLastConfigs

	Search Device Last Configs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteDeviceLastConfigsRequest
	*/
	SearchSiteDeviceLastConfigs(ctx context.Context, siteId string) ApiSearchSiteDeviceLastConfigsRequest

	// SearchSiteDeviceLastConfigsExecute executes the request
	//  @return ResponseConfigHistorySearch
	SearchSiteDeviceLastConfigsExecute(r ApiSearchSiteDeviceLastConfigsRequest) (*ResponseConfigHistorySearch, *http.Response, error)

	/*
	SearchSiteDevices searchSiteDevices

	Search Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteDevicesRequest
	*/
	SearchSiteDevices(ctx context.Context, siteId string) ApiSearchSiteDevicesRequest

	// SearchSiteDevicesExecute executes the request
	//  @return ResponseDeviceSearch
	SearchSiteDevicesExecute(r ApiSearchSiteDevicesRequest) (*ResponseDeviceSearch, *http.Response, error)

	/*
	UpdateSiteDevice updateSiteDevice

	Update Device Configuration

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@return ApiUpdateSiteDeviceRequest
	*/
	UpdateSiteDevice(ctx context.Context, siteId string, deviceId string) ApiUpdateSiteDeviceRequest

	// UpdateSiteDeviceExecute executes the request
	//  @return ResponseDevice
	UpdateSiteDeviceExecute(r ApiUpdateSiteDeviceRequest) (*ResponseDevice, *http.Response, error)
}

// SitesDevicesAPIService SitesDevicesAPI service
type SitesDevicesAPIService service

type ApiAddSiteDeviceImageRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	deviceId string
	imageNumber int32
	file *os.File
	json *string
}

// binary file
func (r ApiAddSiteDeviceImageRequest) File(file *os.File) ApiAddSiteDeviceImageRequest {
	r.file = file
	return r
}

// JSON string describing your upload
func (r ApiAddSiteDeviceImageRequest) Json(json string) ApiAddSiteDeviceImageRequest {
	r.json = &json
	return r
}

func (r ApiAddSiteDeviceImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.AddSiteDeviceImageExecute(r)
}

/*
AddSiteDeviceImage addSiteDeviceImage

Attach up to 3 images to a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @param imageNumber
 @return ApiAddSiteDeviceImageRequest
*/
func (a *SitesDevicesAPIService) AddSiteDeviceImage(ctx context.Context, siteId string, deviceId string, imageNumber int32) ApiAddSiteDeviceImageRequest {
	return ApiAddSiteDeviceImageRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
		imageNumber: imageNumber,
	}
}

// Execute executes the request
func (a *SitesDevicesAPIService) AddSiteDeviceImageExecute(r ApiAddSiteDeviceImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.AddSiteDeviceImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/{device_id}/image{image_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_number"+"}", url.PathEscape(parameterValueToString(r.imageNumber, "imageNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.file == nil {
		return nil, reportError("file is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form_data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	var fileLocalVarFormFileName string
	var fileLocalVarFileName     string
	var fileLocalVarFileBytes    []byte

	fileLocalVarFormFileName = "file"
	fileLocalVarFile := r.file

	if fileLocalVarFile != nil {
		fbs, _ := io.ReadAll(fileLocalVarFile)

		fileLocalVarFileBytes = fbs
		fileLocalVarFileName = fileLocalVarFile.Name()
		fileLocalVarFile.Close()
		formFiles = append(formFiles, formFile{fileBytes: fileLocalVarFileBytes, fileName: fileLocalVarFileName, formFileName: fileLocalVarFormFileName})
	}
	if r.json != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "json", r.json, "")
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiCountSiteDeviceConfigHistoryRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	distinct *string
	mac *string
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountSiteDeviceConfigHistoryRequest) Distinct(distinct string) ApiCountSiteDeviceConfigHistoryRequest {
	r.distinct = &distinct
	return r
}

func (r ApiCountSiteDeviceConfigHistoryRequest) Mac(mac string) ApiCountSiteDeviceConfigHistoryRequest {
	r.mac = &mac
	return r
}

func (r ApiCountSiteDeviceConfigHistoryRequest) Page(page int32) ApiCountSiteDeviceConfigHistoryRequest {
	r.page = &page
	return r
}

func (r ApiCountSiteDeviceConfigHistoryRequest) Limit(limit int32) ApiCountSiteDeviceConfigHistoryRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountSiteDeviceConfigHistoryRequest) Start(start int32) ApiCountSiteDeviceConfigHistoryRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountSiteDeviceConfigHistoryRequest) End(end int32) ApiCountSiteDeviceConfigHistoryRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountSiteDeviceConfigHistoryRequest) Duration(duration string) ApiCountSiteDeviceConfigHistoryRequest {
	r.duration = &duration
	return r
}

func (r ApiCountSiteDeviceConfigHistoryRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteDeviceConfigHistoryExecute(r)
}

/*
CountSiteDeviceConfigHistory countSiteDeviceConfigHistory

Counts the number of entries in device config history for distinct field with given filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteDeviceConfigHistoryRequest
*/
func (a *SitesDevicesAPIService) CountSiteDeviceConfigHistory(ctx context.Context, siteId string) ApiCountSiteDeviceConfigHistoryRequest {
	return ApiCountSiteDeviceConfigHistoryRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesAPIService) CountSiteDeviceConfigHistoryExecute(r ApiCountSiteDeviceConfigHistoryRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.CountSiteDeviceConfigHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/config_history/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountSiteDeviceEventsRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	distinct *SiteDeviceEventsCountDistinct
	model *string
	type_ *string
	typeCode *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountSiteDeviceEventsRequest) Distinct(distinct SiteDeviceEventsCountDistinct) ApiCountSiteDeviceEventsRequest {
	r.distinct = &distinct
	return r
}

func (r ApiCountSiteDeviceEventsRequest) Model(model string) ApiCountSiteDeviceEventsRequest {
	r.model = &model
	return r
}

// see [listDeviceEventsDefinitions]($e/Constants%20Events/listDeviceEventsDefinitions)
func (r ApiCountSiteDeviceEventsRequest) Type_(type_ string) ApiCountSiteDeviceEventsRequest {
	r.type_ = &type_
	return r
}

func (r ApiCountSiteDeviceEventsRequest) TypeCode(typeCode string) ApiCountSiteDeviceEventsRequest {
	r.typeCode = &typeCode
	return r
}

func (r ApiCountSiteDeviceEventsRequest) Limit(limit int32) ApiCountSiteDeviceEventsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountSiteDeviceEventsRequest) Start(start int32) ApiCountSiteDeviceEventsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountSiteDeviceEventsRequest) End(end int32) ApiCountSiteDeviceEventsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountSiteDeviceEventsRequest) Duration(duration string) ApiCountSiteDeviceEventsRequest {
	r.duration = &duration
	return r
}

func (r ApiCountSiteDeviceEventsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteDeviceEventsExecute(r)
}

/*
CountSiteDeviceEvents countSiteDeviceEvents

Counts the number of entries in ap events history for distinct field with given filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteDeviceEventsRequest
*/
func (a *SitesDevicesAPIService) CountSiteDeviceEvents(ctx context.Context, siteId string) ApiCountSiteDeviceEventsRequest {
	return ApiCountSiteDeviceEventsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesAPIService) CountSiteDeviceEventsExecute(r ApiCountSiteDeviceEventsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.CountSiteDeviceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/events/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue SiteDeviceEventsCountDistinct = "model"
		r.distinct = &defaultValue
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.typeCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type_code", r.typeCode, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountSiteDeviceLastConfigRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	distinct *SiteDeviceLastConfigCountDistinct
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountSiteDeviceLastConfigRequest) Distinct(distinct SiteDeviceLastConfigCountDistinct) ApiCountSiteDeviceLastConfigRequest {
	r.distinct = &distinct
	return r
}

func (r ApiCountSiteDeviceLastConfigRequest) Page(page int32) ApiCountSiteDeviceLastConfigRequest {
	r.page = &page
	return r
}

func (r ApiCountSiteDeviceLastConfigRequest) Limit(limit int32) ApiCountSiteDeviceLastConfigRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountSiteDeviceLastConfigRequest) Start(start int32) ApiCountSiteDeviceLastConfigRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountSiteDeviceLastConfigRequest) End(end int32) ApiCountSiteDeviceLastConfigRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountSiteDeviceLastConfigRequest) Duration(duration string) ApiCountSiteDeviceLastConfigRequest {
	r.duration = &duration
	return r
}

func (r ApiCountSiteDeviceLastConfigRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteDeviceLastConfigExecute(r)
}

/*
CountSiteDeviceLastConfig countSiteDeviceLastConfig

Counts the number of entries in device config history for distinct field with given filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteDeviceLastConfigRequest
*/
func (a *SitesDevicesAPIService) CountSiteDeviceLastConfig(ctx context.Context, siteId string) ApiCountSiteDeviceLastConfigRequest {
	return ApiCountSiteDeviceLastConfigRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesAPIService) CountSiteDeviceLastConfigExecute(r ApiCountSiteDeviceLastConfigRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.CountSiteDeviceLastConfig")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/last_config/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue SiteDeviceLastConfigCountDistinct = "mac"
		r.distinct = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountSiteDevicesRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	distinct *SiteDevicesCountDistinct
	hostname *string
	model *string
	mac *string
	version *string
	mxtunnelStatus *string
	mxedgeId *string
	lldpSystemName *string
	lldpSystemDesc *string
	lldpPortId *string
	lldpMgmtAddr *string
	mapId *string
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountSiteDevicesRequest) Distinct(distinct SiteDevicesCountDistinct) ApiCountSiteDevicesRequest {
	r.distinct = &distinct
	return r
}

func (r ApiCountSiteDevicesRequest) Hostname(hostname string) ApiCountSiteDevicesRequest {
	r.hostname = &hostname
	return r
}

func (r ApiCountSiteDevicesRequest) Model(model string) ApiCountSiteDevicesRequest {
	r.model = &model
	return r
}

func (r ApiCountSiteDevicesRequest) Mac(mac string) ApiCountSiteDevicesRequest {
	r.mac = &mac
	return r
}

func (r ApiCountSiteDevicesRequest) Version(version string) ApiCountSiteDevicesRequest {
	r.version = &version
	return r
}

func (r ApiCountSiteDevicesRequest) MxtunnelStatus(mxtunnelStatus string) ApiCountSiteDevicesRequest {
	r.mxtunnelStatus = &mxtunnelStatus
	return r
}

func (r ApiCountSiteDevicesRequest) MxedgeId(mxedgeId string) ApiCountSiteDevicesRequest {
	r.mxedgeId = &mxedgeId
	return r
}

func (r ApiCountSiteDevicesRequest) LldpSystemName(lldpSystemName string) ApiCountSiteDevicesRequest {
	r.lldpSystemName = &lldpSystemName
	return r
}

func (r ApiCountSiteDevicesRequest) LldpSystemDesc(lldpSystemDesc string) ApiCountSiteDevicesRequest {
	r.lldpSystemDesc = &lldpSystemDesc
	return r
}

func (r ApiCountSiteDevicesRequest) LldpPortId(lldpPortId string) ApiCountSiteDevicesRequest {
	r.lldpPortId = &lldpPortId
	return r
}

func (r ApiCountSiteDevicesRequest) LldpMgmtAddr(lldpMgmtAddr string) ApiCountSiteDevicesRequest {
	r.lldpMgmtAddr = &lldpMgmtAddr
	return r
}

func (r ApiCountSiteDevicesRequest) MapId(mapId string) ApiCountSiteDevicesRequest {
	r.mapId = &mapId
	return r
}

func (r ApiCountSiteDevicesRequest) Page(page int32) ApiCountSiteDevicesRequest {
	r.page = &page
	return r
}

func (r ApiCountSiteDevicesRequest) Limit(limit int32) ApiCountSiteDevicesRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountSiteDevicesRequest) Start(start int32) ApiCountSiteDevicesRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountSiteDevicesRequest) End(end int32) ApiCountSiteDevicesRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountSiteDevicesRequest) Duration(duration string) ApiCountSiteDevicesRequest {
	r.duration = &duration
	return r
}

func (r ApiCountSiteDevicesRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteDevicesExecute(r)
}

/*
CountSiteDevices countSiteDevices

Counts the number of entries in ap events history for distinct field with given filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteDevicesRequest
*/
func (a *SitesDevicesAPIService) CountSiteDevices(ctx context.Context, siteId string) ApiCountSiteDevicesRequest {
	return ApiCountSiteDevicesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesAPIService) CountSiteDevicesExecute(r ApiCountSiteDevicesRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.CountSiteDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue SiteDevicesCountDistinct = "model"
		r.distinct = &defaultValue
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.mxtunnelStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxtunnel_status", r.mxtunnelStatus, "")
	}
	if r.mxedgeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxedge_id", r.mxedgeId, "")
	}
	if r.lldpSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_name", r.lldpSystemName, "")
	}
	if r.lldpSystemDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_desc", r.lldpSystemDesc, "")
	}
	if r.lldpPortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_port_id", r.lldpPortId, "")
	}
	if r.lldpMgmtAddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_mgmt_addr", r.lldpMgmtAddr, "")
	}
	if r.mapId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "map_id", r.mapId, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteSiteDeviceRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	deviceId string
}

func (r ApiDeleteSiteDeviceRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSiteDeviceExecute(r)
}

/*
DeleteSiteDevice deleteSiteDevice

Delete Site Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @return ApiDeleteSiteDeviceRequest
*/
func (a *SitesDevicesAPIService) DeleteSiteDevice(ctx context.Context, siteId string, deviceId string) ApiDeleteSiteDeviceRequest {
	return ApiDeleteSiteDeviceRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
	}
}

// Execute executes the request
func (a *SitesDevicesAPIService) DeleteSiteDeviceExecute(r ApiDeleteSiteDeviceRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.DeleteSiteDevice")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiDeleteSiteDeviceImageRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	deviceId string
	imageNumber int32
}

func (r ApiDeleteSiteDeviceImageRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeleteSiteDeviceImageExecute(r)
}

/*
DeleteSiteDeviceImage deleteSiteDeviceImage

Delete image from a device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @param imageNumber
 @return ApiDeleteSiteDeviceImageRequest
*/
func (a *SitesDevicesAPIService) DeleteSiteDeviceImage(ctx context.Context, siteId string, deviceId string, imageNumber int32) ApiDeleteSiteDeviceImageRequest {
	return ApiDeleteSiteDeviceImageRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
		imageNumber: imageNumber,
	}
}

// Execute executes the request
func (a *SitesDevicesAPIService) DeleteSiteDeviceImageExecute(r ApiDeleteSiteDeviceImageRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.DeleteSiteDeviceImage")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/{device_id}/image{image_number}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"image_number"+"}", url.PathEscape(parameterValueToString(r.imageNumber, "imageNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiExportSiteDevicesRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
}

func (r ApiExportSiteDevicesRequest) Execute() (*os.File, *http.Response, error) {
	return r.ApiService.ExportSiteDevicesExecute(r)
}

/*
ExportSiteDevices exportSiteDevices

To download the exported device information

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiExportSiteDevicesRequest
*/
func (a *SitesDevicesAPIService) ExportSiteDevices(ctx context.Context, siteId string) ApiExportSiteDevicesRequest {
	return ApiExportSiteDevicesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return *os.File
func (a *SitesDevicesAPIService) ExportSiteDevicesExecute(r ApiExportSiteDevicesRequest) (*os.File, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *os.File
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.ExportSiteDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/export"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteDeviceRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	deviceId string
}

func (r ApiGetSiteDeviceRequest) Execute() (*ResponseDevice, *http.Response, error) {
	return r.ApiService.GetSiteDeviceExecute(r)
}

/*
GetSiteDevice getSiteDevice

Get Device Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @return ApiGetSiteDeviceRequest
*/
func (a *SitesDevicesAPIService) GetSiteDevice(ctx context.Context, siteId string, deviceId string) ApiGetSiteDeviceRequest {
	return ApiGetSiteDeviceRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return ResponseDevice
func (a *SitesDevicesAPIService) GetSiteDeviceExecute(r ApiGetSiteDeviceRequest) (*ResponseDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.GetSiteDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiImportSiteDevicesRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	ap *[]Ap
}

func (r ApiImportSiteDevicesRequest) Ap(ap []Ap) ApiImportSiteDevicesRequest {
	r.ap = &ap
	return r
}

func (r ApiImportSiteDevicesRequest) Execute() ([]ConfigDevice, *http.Response, error) {
	return r.ApiService.ImportSiteDevicesExecute(r)
}

/*
ImportSiteDevices importSiteDevices

Import Information for Multiple Devices

CSV format:
```csv
mac,name,map_id,x,y,height,orientation,labels,band_24.power,band_24.bandwidth,band_24.channel,band_24.disabled,band_5.power,band_5.bandwidth,band_5.channel,band_5.disabled,band_6.power,band_6.bandwidth,band_6.channel,band_6.disabled
5c5b53010101,"AP 1",845a23bf-bed9-e43c-4c86-6fa474be7ae5,30,10,2.3,45,"guest, campus, vip",1,20,0,false,0,40,0,false,17,80,0,false
```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiImportSiteDevicesRequest
*/
func (a *SitesDevicesAPIService) ImportSiteDevices(ctx context.Context, siteId string) ApiImportSiteDevicesRequest {
	return ApiImportSiteDevicesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []ConfigDevice
func (a *SitesDevicesAPIService) ImportSiteDevicesExecute(r ApiImportSiteDevicesRequest) ([]ConfigDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConfigDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.ImportSiteDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/import"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/octet-stream"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.ap
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSiteDevicesRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	type_ *DeviceTypeWithAll
	name *string
	page *int32
	limit *int32
}

func (r ApiListSiteDevicesRequest) Type_(type_ DeviceTypeWithAll) ApiListSiteDevicesRequest {
	r.type_ = &type_
	return r
}

func (r ApiListSiteDevicesRequest) Name(name string) ApiListSiteDevicesRequest {
	r.name = &name
	return r
}

func (r ApiListSiteDevicesRequest) Page(page int32) ApiListSiteDevicesRequest {
	r.page = &page
	return r
}

func (r ApiListSiteDevicesRequest) Limit(limit int32) ApiListSiteDevicesRequest {
	r.limit = &limit
	return r
}

func (r ApiListSiteDevicesRequest) Execute() ([]ConfigDevice, *http.Response, error) {
	return r.ApiService.ListSiteDevicesExecute(r)
}

/*
ListSiteDevices listSiteDevices

Get list of devices on the site.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiListSiteDevicesRequest
*/
func (a *SitesDevicesAPIService) ListSiteDevices(ctx context.Context, siteId string) ApiListSiteDevicesRequest {
	return ApiListSiteDevicesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []ConfigDevice
func (a *SitesDevicesAPIService) ListSiteDevicesExecute(r ApiListSiteDevicesRequest) ([]ConfigDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ConfigDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.ListSiteDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceTypeWithAll = "ap"
		r.type_ = &defaultValue
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	} else {
		var defaultValue string = ""
		r.name = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRestartSiteMultipleDevicesRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	utilsDevicesRestartMulti *UtilsDevicesRestartMulti
}

// Request Body
func (r ApiRestartSiteMultipleDevicesRequest) UtilsDevicesRestartMulti(utilsDevicesRestartMulti UtilsDevicesRestartMulti) ApiRestartSiteMultipleDevicesRequest {
	r.utilsDevicesRestartMulti = &utilsDevicesRestartMulti
	return r
}

func (r ApiRestartSiteMultipleDevicesRequest) Execute() (*http.Response, error) {
	return r.ApiService.RestartSiteMultipleDevicesExecute(r)
}

/*
RestartSiteMultipleDevices restartSiteMultipleDevices

Note that only the devices that are connected will be restarted.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiRestartSiteMultipleDevicesRequest
*/
func (a *SitesDevicesAPIService) RestartSiteMultipleDevices(ctx context.Context, siteId string) ApiRestartSiteMultipleDevicesRequest {
	return ApiRestartSiteMultipleDevicesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
func (a *SitesDevicesAPIService) RestartSiteMultipleDevicesExecute(r ApiRestartSiteMultipleDevicesRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.RestartSiteMultipleDevices")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/restart"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.utilsDevicesRestartMulti
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiSearchSiteDeviceConfigHistoryRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	type_ *DeviceType
	mac *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiSearchSiteDeviceConfigHistoryRequest) Type_(type_ DeviceType) ApiSearchSiteDeviceConfigHistoryRequest {
	r.type_ = &type_
	return r
}

// Device MAC Address
func (r ApiSearchSiteDeviceConfigHistoryRequest) Mac(mac string) ApiSearchSiteDeviceConfigHistoryRequest {
	r.mac = &mac
	return r
}

func (r ApiSearchSiteDeviceConfigHistoryRequest) Limit(limit int32) ApiSearchSiteDeviceConfigHistoryRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchSiteDeviceConfigHistoryRequest) Start(start int32) ApiSearchSiteDeviceConfigHistoryRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchSiteDeviceConfigHistoryRequest) End(end int32) ApiSearchSiteDeviceConfigHistoryRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchSiteDeviceConfigHistoryRequest) Duration(duration string) ApiSearchSiteDeviceConfigHistoryRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchSiteDeviceConfigHistoryRequest) Execute() (*ResponseConfigHistorySearch, *http.Response, error) {
	return r.ApiService.SearchSiteDeviceConfigHistoryExecute(r)
}

/*
SearchSiteDeviceConfigHistory searchSiteDeviceConfigHistory

Search for entries in device config history

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteDeviceConfigHistoryRequest
*/
func (a *SitesDevicesAPIService) SearchSiteDeviceConfigHistory(ctx context.Context, siteId string) ApiSearchSiteDeviceConfigHistoryRequest {
	return ApiSearchSiteDeviceConfigHistoryRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseConfigHistorySearch
func (a *SitesDevicesAPIService) SearchSiteDeviceConfigHistoryExecute(r ApiSearchSiteDeviceConfigHistoryRequest) (*ResponseConfigHistorySearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseConfigHistorySearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.SearchSiteDeviceConfigHistory")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/config_history/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceType = "ap"
		r.type_ = &defaultValue
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSiteDeviceEventsRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	mac *string
	model *string
	text *string
	timestamp *string
	type_ *string
	lastBy *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

// device mac
func (r ApiSearchSiteDeviceEventsRequest) Mac(mac string) ApiSearchSiteDeviceEventsRequest {
	r.mac = &mac
	return r
}

// device model
func (r ApiSearchSiteDeviceEventsRequest) Model(model string) ApiSearchSiteDeviceEventsRequest {
	r.model = &model
	return r
}

// event message
func (r ApiSearchSiteDeviceEventsRequest) Text(text string) ApiSearchSiteDeviceEventsRequest {
	r.text = &text
	return r
}

// event time
func (r ApiSearchSiteDeviceEventsRequest) Timestamp(timestamp string) ApiSearchSiteDeviceEventsRequest {
	r.timestamp = &timestamp
	return r
}

// see [listDeviceEventsDefinitions]($e/Constants%20Events/listDeviceEventsDefinitions)
func (r ApiSearchSiteDeviceEventsRequest) Type_(type_ string) ApiSearchSiteDeviceEventsRequest {
	r.type_ = &type_
	return r
}

// Return last/recent event for passed in field
func (r ApiSearchSiteDeviceEventsRequest) LastBy(lastBy string) ApiSearchSiteDeviceEventsRequest {
	r.lastBy = &lastBy
	return r
}

func (r ApiSearchSiteDeviceEventsRequest) Limit(limit int32) ApiSearchSiteDeviceEventsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchSiteDeviceEventsRequest) Start(start int32) ApiSearchSiteDeviceEventsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchSiteDeviceEventsRequest) End(end int32) ApiSearchSiteDeviceEventsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchSiteDeviceEventsRequest) Duration(duration string) ApiSearchSiteDeviceEventsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchSiteDeviceEventsRequest) Execute() (*ResponseEventsDevices, *http.Response, error) {
	return r.ApiService.SearchSiteDeviceEventsExecute(r)
}

/*
SearchSiteDeviceEvents searchSiteDeviceEvents

Search Devices Events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteDeviceEventsRequest
*/
func (a *SitesDevicesAPIService) SearchSiteDeviceEvents(ctx context.Context, siteId string) ApiSearchSiteDeviceEventsRequest {
	return ApiSearchSiteDeviceEventsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseEventsDevices
func (a *SitesDevicesAPIService) SearchSiteDeviceEventsExecute(r ApiSearchSiteDeviceEventsRequest) (*ResponseEventsDevices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseEventsDevices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.SearchSiteDeviceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/events/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.lastBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_by", r.lastBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSiteDeviceLastConfigsRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	type_ *DeviceType
	mac *string
	version *string
	name *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiSearchSiteDeviceLastConfigsRequest) Type_(type_ DeviceType) ApiSearchSiteDeviceLastConfigsRequest {
	r.type_ = &type_
	return r
}

func (r ApiSearchSiteDeviceLastConfigsRequest) Mac(mac string) ApiSearchSiteDeviceLastConfigsRequest {
	r.mac = &mac
	return r
}

func (r ApiSearchSiteDeviceLastConfigsRequest) Version(version string) ApiSearchSiteDeviceLastConfigsRequest {
	r.version = &version
	return r
}

func (r ApiSearchSiteDeviceLastConfigsRequest) Name(name string) ApiSearchSiteDeviceLastConfigsRequest {
	r.name = &name
	return r
}

func (r ApiSearchSiteDeviceLastConfigsRequest) Limit(limit int32) ApiSearchSiteDeviceLastConfigsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchSiteDeviceLastConfigsRequest) Start(start int32) ApiSearchSiteDeviceLastConfigsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchSiteDeviceLastConfigsRequest) End(end int32) ApiSearchSiteDeviceLastConfigsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchSiteDeviceLastConfigsRequest) Duration(duration string) ApiSearchSiteDeviceLastConfigsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchSiteDeviceLastConfigsRequest) Execute() (*ResponseConfigHistorySearch, *http.Response, error) {
	return r.ApiService.SearchSiteDeviceLastConfigsExecute(r)
}

/*
SearchSiteDeviceLastConfigs searchSiteDeviceLastConfigs

Search Device Last Configs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteDeviceLastConfigsRequest
*/
func (a *SitesDevicesAPIService) SearchSiteDeviceLastConfigs(ctx context.Context, siteId string) ApiSearchSiteDeviceLastConfigsRequest {
	return ApiSearchSiteDeviceLastConfigsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseConfigHistorySearch
func (a *SitesDevicesAPIService) SearchSiteDeviceLastConfigsExecute(r ApiSearchSiteDeviceLastConfigsRequest) (*ResponseConfigHistorySearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseConfigHistorySearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.SearchSiteDeviceLastConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/last_config/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceType = "ap"
		r.type_ = &defaultValue
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSiteDevicesRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	hostname *string
	type_ *DeviceType
	model *string
	mac *string
	version *string
	powerConstrained *bool
	ipAddress *string
	mxtunnelStatus *SearchSiteDevicesMxtunnelStatus
	mxedgeId *string
	lldpSystemName *string
	lldpSystemDesc *string
	lldpPortId *string
	lldpMgmtAddr *string
	band24Channel *int32
	band5Channel *int32
	band6Channel *int32
	band24Bandwith *int32
	band5Bandwith *int32
	band6Bandwith *int32
	eth0PortSpeed *int32
	sort *SearchSiteDevicesSort
	descSort *SearchSiteDevicesDescSort
	stats *bool
	limit *int32
	start *int32
	end *int32
	duration *string
}

// partial / full hostname
func (r ApiSearchSiteDevicesRequest) Hostname(hostname string) ApiSearchSiteDevicesRequest {
	r.hostname = &hostname
	return r
}

func (r ApiSearchSiteDevicesRequest) Type_(type_ DeviceType) ApiSearchSiteDevicesRequest {
	r.type_ = &type_
	return r
}

// device model
func (r ApiSearchSiteDevicesRequest) Model(model string) ApiSearchSiteDevicesRequest {
	r.model = &model
	return r
}

// device MAC
func (r ApiSearchSiteDevicesRequest) Mac(mac string) ApiSearchSiteDevicesRequest {
	r.mac = &mac
	return r
}

// version
func (r ApiSearchSiteDevicesRequest) Version(version string) ApiSearchSiteDevicesRequest {
	r.version = &version
	return r
}

// power_constrained
func (r ApiSearchSiteDevicesRequest) PowerConstrained(powerConstrained bool) ApiSearchSiteDevicesRequest {
	r.powerConstrained = &powerConstrained
	return r
}

func (r ApiSearchSiteDevicesRequest) IpAddress(ipAddress string) ApiSearchSiteDevicesRequest {
	r.ipAddress = &ipAddress
	return r
}

// MxTunnel status, up / down
func (r ApiSearchSiteDevicesRequest) MxtunnelStatus(mxtunnelStatus SearchSiteDevicesMxtunnelStatus) ApiSearchSiteDevicesRequest {
	r.mxtunnelStatus = &mxtunnelStatus
	return r
}

// Mist Edge id, if AP is connecting to a Mist Edge
func (r ApiSearchSiteDevicesRequest) MxedgeId(mxedgeId string) ApiSearchSiteDevicesRequest {
	r.mxedgeId = &mxedgeId
	return r
}

// LLDP system name
func (r ApiSearchSiteDevicesRequest) LldpSystemName(lldpSystemName string) ApiSearchSiteDevicesRequest {
	r.lldpSystemName = &lldpSystemName
	return r
}

// LLDP system description
func (r ApiSearchSiteDevicesRequest) LldpSystemDesc(lldpSystemDesc string) ApiSearchSiteDevicesRequest {
	r.lldpSystemDesc = &lldpSystemDesc
	return r
}

// LLDP port id
func (r ApiSearchSiteDevicesRequest) LldpPortId(lldpPortId string) ApiSearchSiteDevicesRequest {
	r.lldpPortId = &lldpPortId
	return r
}

// LLDP management ip address
func (r ApiSearchSiteDevicesRequest) LldpMgmtAddr(lldpMgmtAddr string) ApiSearchSiteDevicesRequest {
	r.lldpMgmtAddr = &lldpMgmtAddr
	return r
}

// Channel of band_24
func (r ApiSearchSiteDevicesRequest) Band24Channel(band24Channel int32) ApiSearchSiteDevicesRequest {
	r.band24Channel = &band24Channel
	return r
}

// Channel of band_5
func (r ApiSearchSiteDevicesRequest) Band5Channel(band5Channel int32) ApiSearchSiteDevicesRequest {
	r.band5Channel = &band5Channel
	return r
}

// Channel of band_6
func (r ApiSearchSiteDevicesRequest) Band6Channel(band6Channel int32) ApiSearchSiteDevicesRequest {
	r.band6Channel = &band6Channel
	return r
}

// Bandwidth of band_24
func (r ApiSearchSiteDevicesRequest) Band24Bandwith(band24Bandwith int32) ApiSearchSiteDevicesRequest {
	r.band24Bandwith = &band24Bandwith
	return r
}

// Bandwidth of band_5
func (r ApiSearchSiteDevicesRequest) Band5Bandwith(band5Bandwith int32) ApiSearchSiteDevicesRequest {
	r.band5Bandwith = &band5Bandwith
	return r
}

// Bandwidth of band_6
func (r ApiSearchSiteDevicesRequest) Band6Bandwith(band6Bandwith int32) ApiSearchSiteDevicesRequest {
	r.band6Bandwith = &band6Bandwith
	return r
}

// Port speed of eth0
func (r ApiSearchSiteDevicesRequest) Eth0PortSpeed(eth0PortSpeed int32) ApiSearchSiteDevicesRequest {
	r.eth0PortSpeed = &eth0PortSpeed
	return r
}

// sort options
func (r ApiSearchSiteDevicesRequest) Sort(sort SearchSiteDevicesSort) ApiSearchSiteDevicesRequest {
	r.sort = &sort
	return r
}

// sort options in reverse order
func (r ApiSearchSiteDevicesRequest) DescSort(descSort SearchSiteDevicesDescSort) ApiSearchSiteDevicesRequest {
	r.descSort = &descSort
	return r
}

// whether to return device stats
func (r ApiSearchSiteDevicesRequest) Stats(stats bool) ApiSearchSiteDevicesRequest {
	r.stats = &stats
	return r
}

func (r ApiSearchSiteDevicesRequest) Limit(limit int32) ApiSearchSiteDevicesRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchSiteDevicesRequest) Start(start int32) ApiSearchSiteDevicesRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchSiteDevicesRequest) End(end int32) ApiSearchSiteDevicesRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchSiteDevicesRequest) Duration(duration string) ApiSearchSiteDevicesRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchSiteDevicesRequest) Execute() (*ResponseDeviceSearch, *http.Response, error) {
	return r.ApiService.SearchSiteDevicesExecute(r)
}

/*
SearchSiteDevices searchSiteDevices

Search Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteDevicesRequest
*/
func (a *SitesDevicesAPIService) SearchSiteDevices(ctx context.Context, siteId string) ApiSearchSiteDevicesRequest {
	return ApiSearchSiteDevicesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseDeviceSearch
func (a *SitesDevicesAPIService) SearchSiteDevicesExecute(r ApiSearchSiteDevicesRequest) (*ResponseDeviceSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseDeviceSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.SearchSiteDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceType = "ap"
		r.type_ = &defaultValue
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.powerConstrained != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_constrained", r.powerConstrained, "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", r.ipAddress, "")
	}
	if r.mxtunnelStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxtunnel_status", r.mxtunnelStatus, "")
	}
	if r.mxedgeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxedge_id", r.mxedgeId, "")
	}
	if r.lldpSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_name", r.lldpSystemName, "")
	}
	if r.lldpSystemDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_desc", r.lldpSystemDesc, "")
	}
	if r.lldpPortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_port_id", r.lldpPortId, "")
	}
	if r.lldpMgmtAddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_mgmt_addr", r.lldpMgmtAddr, "")
	}
	if r.band24Channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_24_channel", r.band24Channel, "")
	}
	if r.band5Channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_5_channel", r.band5Channel, "")
	}
	if r.band6Channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_6_channel", r.band6Channel, "")
	}
	if r.band24Bandwith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_24_bandwith", r.band24Bandwith, "")
	}
	if r.band5Bandwith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_5_bandwith", r.band5Bandwith, "")
	}
	if r.band6Bandwith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_6_bandwith", r.band6Bandwith, "")
	}
	if r.eth0PortSpeed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eth0_port_speed", r.eth0PortSpeed, "")
	}
	if r.sort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sort", r.sort, "")
	} else {
		var defaultValue SearchSiteDevicesSort = "timestamp"
		r.sort = &defaultValue
	}
	if r.descSort != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "desc_sort", r.descSort, "")
	}
	if r.stats != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stats", r.stats, "")
	} else {
		var defaultValue bool = false
		r.stats = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiteDeviceRequest struct {
	ctx context.Context
	ApiService SitesDevicesAPI
	siteId string
	deviceId string
	mistDevice *MistDevice
}

// Request Body
func (r ApiUpdateSiteDeviceRequest) MistDevice(mistDevice MistDevice) ApiUpdateSiteDeviceRequest {
	r.mistDevice = &mistDevice
	return r
}

func (r ApiUpdateSiteDeviceRequest) Execute() (*ResponseDevice, *http.Response, error) {
	return r.ApiService.UpdateSiteDeviceExecute(r)
}

/*
UpdateSiteDevice updateSiteDevice

Update Device Configuration

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @return ApiUpdateSiteDeviceRequest
*/
func (a *SitesDevicesAPIService) UpdateSiteDevice(ctx context.Context, siteId string, deviceId string) ApiUpdateSiteDeviceRequest {
	return ApiUpdateSiteDeviceRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return ResponseDevice
func (a *SitesDevicesAPIService) UpdateSiteDeviceExecute(r ApiUpdateSiteDeviceRequest) (*ResponseDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesAPIService.UpdateSiteDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.mistDevice
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
