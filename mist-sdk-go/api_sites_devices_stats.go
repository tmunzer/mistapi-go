/*
Mist API

> Version: **2406.1.14** > > Date: **July 3, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.14
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SitesDevicesStatsAPI interface {

	/*
	CountSiteBgpStats countSiteBgpStats

	Count BGP Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteBgpStatsRequest
	*/
	CountSiteBgpStats(ctx context.Context, siteId string) ApiCountSiteBgpStatsRequest

	// CountSiteBgpStatsExecute executes the request
	//  @return RepsonseCount
	CountSiteBgpStatsExecute(r ApiCountSiteBgpStatsRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountSiteSwOrGwPorts countSiteSwOrGwPorts

	Count by Distinct Attributes of Switch/Gateway Ports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteSwOrGwPortsRequest
	*/
	CountSiteSwOrGwPorts(ctx context.Context, siteId string) ApiCountSiteSwOrGwPortsRequest

	// CountSiteSwOrGwPortsExecute executes the request
	//  @return RepsonseCount
	CountSiteSwOrGwPortsExecute(r ApiCountSiteSwOrGwPortsRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountSiteSwitchPorts countSiteSwitchPorts

	Count by Distinct Attributes of Switch/Gateway Ports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiCountSiteSwitchPortsRequest
	*/
	CountSiteSwitchPorts(ctx context.Context, siteId string) ApiCountSiteSwitchPortsRequest

	// CountSiteSwitchPortsExecute executes the request
	//  @return RepsonseCount
	CountSiteSwitchPortsExecute(r ApiCountSiteSwitchPortsRequest) (*RepsonseCount, *http.Response, error)

	/*
	GetSiteAllClientsStatsByDevice getSiteAllClientsStatsByDevice

	Get wireless client stat by Device

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@return ApiGetSiteAllClientsStatsByDeviceRequest
	*/
	GetSiteAllClientsStatsByDevice(ctx context.Context, siteId string, deviceId string) ApiGetSiteAllClientsStatsByDeviceRequest

	// GetSiteAllClientsStatsByDeviceExecute executes the request
	//  @return [][]ClientWirelessStats
	GetSiteAllClientsStatsByDeviceExecute(r ApiGetSiteAllClientsStatsByDeviceRequest) ([][]ClientWirelessStats, *http.Response, error)

	/*
	GetSiteDeviceStats getSiteDeviceStats

	Get Site Device Stats Details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param deviceId
	@return ApiGetSiteDeviceStatsRequest
	*/
	GetSiteDeviceStats(ctx context.Context, siteId string, deviceId string) ApiGetSiteDeviceStatsRequest

	// GetSiteDeviceStatsExecute executes the request
	//  @return StatsDevice
	GetSiteDeviceStatsExecute(r ApiGetSiteDeviceStatsRequest) (*StatsDevice, *http.Response, error)

	/*
	GetSiteGatewayMetrics getSiteGatewayMetrics

	Get Site Gateway Metrics

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiGetSiteGatewayMetricsRequest
	*/
	GetSiteGatewayMetrics(ctx context.Context, siteId string) ApiGetSiteGatewayMetricsRequest

	// GetSiteGatewayMetricsExecute executes the request
	//  @return GatewayMetrics
	GetSiteGatewayMetricsExecute(r ApiGetSiteGatewayMetricsRequest) (*GatewayMetrics, *http.Response, error)

	/*
	GetSiteMxEdgeStats getSiteMxEdgeStats

	Get One Site MxEdge Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param mxedgeId
	@return ApiGetSiteMxEdgeStatsRequest
	*/
	GetSiteMxEdgeStats(ctx context.Context, siteId string, mxedgeId string) ApiGetSiteMxEdgeStatsRequest

	// GetSiteMxEdgeStatsExecute executes the request
	//  @return MxedgeStats
	GetSiteMxEdgeStatsExecute(r ApiGetSiteMxEdgeStatsRequest) (*MxedgeStats, *http.Response, error)

	/*
	ListSiteDevicesStats listSiteDevicesStats

	Get List of Site Devices Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiListSiteDevicesStatsRequest
	*/
	ListSiteDevicesStats(ctx context.Context, siteId string) ApiListSiteDevicesStatsRequest

	// ListSiteDevicesStatsExecute executes the request
	//  @return []ResponseStatsDevice
	ListSiteDevicesStatsExecute(r ApiListSiteDevicesStatsRequest) ([]ResponseStatsDevice, *http.Response, error)

	/*
	ListSiteMxEdgesStats listSiteMxEdgesStats

	Get List of Site MxEdges Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiListSiteMxEdgesStatsRequest
	*/
	ListSiteMxEdgesStats(ctx context.Context, siteId string) ApiListSiteMxEdgesStatsRequest

	// ListSiteMxEdgesStatsExecute executes the request
	//  @return []MxedgeStats
	ListSiteMxEdgesStatsExecute(r ApiListSiteMxEdgesStatsRequest) ([]MxedgeStats, *http.Response, error)

	/*
	SearchSiteBgpStats searchSiteBgpStats

	Search BGP Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteBgpStatsRequest
	*/
	SearchSiteBgpStats(ctx context.Context, siteId string) ApiSearchSiteBgpStatsRequest

	// SearchSiteBgpStatsExecute executes the request
	//  @return ResponseSearchBgps
	SearchSiteBgpStatsExecute(r ApiSearchSiteBgpStatsRequest) (*ResponseSearchBgps, *http.Response, error)

	/*
	SearchSiteSwOrGwPorts searchSiteSwOrGwPorts

	Search Switch / Gateway Ports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteSwOrGwPortsRequest
	*/
	SearchSiteSwOrGwPorts(ctx context.Context, siteId string) ApiSearchSiteSwOrGwPortsRequest

	// SearchSiteSwOrGwPortsExecute executes the request
	//  @return ResponseSwitchPortSearch
	SearchSiteSwOrGwPortsExecute(r ApiSearchSiteSwOrGwPortsRequest) (*ResponseSwitchPortSearch, *http.Response, error)

	/*
	SearchSiteSwitchPorts searchSiteSwitchPorts

	Search Switch / Gateway Ports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@return ApiSearchSiteSwitchPortsRequest
	*/
	SearchSiteSwitchPorts(ctx context.Context, siteId string) ApiSearchSiteSwitchPortsRequest

	// SearchSiteSwitchPortsExecute executes the request
	//  @return ResponseSwitchPortSearch
	SearchSiteSwitchPortsExecute(r ApiSearchSiteSwitchPortsRequest) (*ResponseSwitchPortSearch, *http.Response, error)
}

// SitesDevicesStatsAPIService SitesDevicesStatsAPI service
type SitesDevicesStatsAPIService service

type ApiCountSiteBgpStatsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	state *string
	distinct *string
}

func (r ApiCountSiteBgpStatsRequest) State(state string) ApiCountSiteBgpStatsRequest {
	r.state = &state
	return r
}

func (r ApiCountSiteBgpStatsRequest) Distinct(distinct string) ApiCountSiteBgpStatsRequest {
	r.distinct = &distinct
	return r
}

func (r ApiCountSiteBgpStatsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteBgpStatsExecute(r)
}

/*
CountSiteBgpStats countSiteBgpStats

Count BGP Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteBgpStatsRequest
*/
func (a *SitesDevicesStatsAPIService) CountSiteBgpStats(ctx context.Context, siteId string) ApiCountSiteBgpStatsRequest {
	return ApiCountSiteBgpStatsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesStatsAPIService) CountSiteBgpStatsExecute(r ApiCountSiteBgpStatsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.CountSiteBgpStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/bgp_peers/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.state != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "state", r.state, "")
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountSiteSwOrGwPortsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	distinct *SitePortsCountDistinct
	fullDuplex *bool
	mac *string
	neighborMac *string
	neighborPortDesc *string
	neighborSystemName *string
	poeDisabled *bool
	poeMode *string
	poeOn *bool
	portId *string
	portMac *string
	powerDraw *float32
	txPkts *int32
	rxPkts *int32
	rxBytes *int32
	txBps *int32
	rxBps *int32
	txMcastPkts *int32
	txBcastPkts *int32
	rxMcastPkts *int32
	rxBcastPkts *int32
	speed *int32
	stpState *CountSiteSwOrGwPortsStpState
	stpRole *CountSiteSwOrGwPortsStpRole
	authState *CountSiteSwOrGwPortsAuthState
	up *bool
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountSiteSwOrGwPortsRequest) Distinct(distinct SitePortsCountDistinct) ApiCountSiteSwOrGwPortsRequest {
	r.distinct = &distinct
	return r
}

// indicates full or half duplex
func (r ApiCountSiteSwOrGwPortsRequest) FullDuplex(fullDuplex bool) ApiCountSiteSwOrGwPortsRequest {
	r.fullDuplex = &fullDuplex
	return r
}

// device identifier
func (r ApiCountSiteSwOrGwPortsRequest) Mac(mac string) ApiCountSiteSwOrGwPortsRequest {
	r.mac = &mac
	return r
}

// Chassis identifier of the chassis type listed
func (r ApiCountSiteSwOrGwPortsRequest) NeighborMac(neighborMac string) ApiCountSiteSwOrGwPortsRequest {
	r.neighborMac = &neighborMac
	return r
}

// Description supplied by the system on the interface E.g. “GigabitEthernet2/0/39”
func (r ApiCountSiteSwOrGwPortsRequest) NeighborPortDesc(neighborPortDesc string) ApiCountSiteSwOrGwPortsRequest {
	r.neighborPortDesc = &neighborPortDesc
	return r
}

// Name supplied by the system on the interface E.g. neighbor system name E.g. “Kumar-Acc-SW.mist.local”
func (r ApiCountSiteSwOrGwPortsRequest) NeighborSystemName(neighborSystemName string) ApiCountSiteSwOrGwPortsRequest {
	r.neighborSystemName = &neighborSystemName
	return r
}

// is the POE configured not be disabled.
func (r ApiCountSiteSwOrGwPortsRequest) PoeDisabled(poeDisabled bool) ApiCountSiteSwOrGwPortsRequest {
	r.poeDisabled = &poeDisabled
	return r
}

// poe mode depending on class E.g. “802.3at”
func (r ApiCountSiteSwOrGwPortsRequest) PoeMode(poeMode string) ApiCountSiteSwOrGwPortsRequest {
	r.poeMode = &poeMode
	return r
}

// is the device attached to POE
func (r ApiCountSiteSwOrGwPortsRequest) PoeOn(poeOn bool) ApiCountSiteSwOrGwPortsRequest {
	r.poeOn = &poeOn
	return r
}

// interface name
func (r ApiCountSiteSwOrGwPortsRequest) PortId(portId string) ApiCountSiteSwOrGwPortsRequest {
	r.portId = &portId
	return r
}

// interface mac address
func (r ApiCountSiteSwOrGwPortsRequest) PortMac(portMac string) ApiCountSiteSwOrGwPortsRequest {
	r.portMac = &portMac
	return r
}

// Amount of power being used by the interface at the time the command is executed. Unit in watts.
func (r ApiCountSiteSwOrGwPortsRequest) PowerDraw(powerDraw float32) ApiCountSiteSwOrGwPortsRequest {
	r.powerDraw = &powerDraw
	return r
}

// Output packets
func (r ApiCountSiteSwOrGwPortsRequest) TxPkts(txPkts int32) ApiCountSiteSwOrGwPortsRequest {
	r.txPkts = &txPkts
	return r
}

// Input packets
func (r ApiCountSiteSwOrGwPortsRequest) RxPkts(rxPkts int32) ApiCountSiteSwOrGwPortsRequest {
	r.rxPkts = &rxPkts
	return r
}

// Input bytes
func (r ApiCountSiteSwOrGwPortsRequest) RxBytes(rxBytes int32) ApiCountSiteSwOrGwPortsRequest {
	r.rxBytes = &rxBytes
	return r
}

// Output rate
func (r ApiCountSiteSwOrGwPortsRequest) TxBps(txBps int32) ApiCountSiteSwOrGwPortsRequest {
	r.txBps = &txBps
	return r
}

// Input rate
func (r ApiCountSiteSwOrGwPortsRequest) RxBps(rxBps int32) ApiCountSiteSwOrGwPortsRequest {
	r.rxBps = &rxBps
	return r
}

// Multicast output packets
func (r ApiCountSiteSwOrGwPortsRequest) TxMcastPkts(txMcastPkts int32) ApiCountSiteSwOrGwPortsRequest {
	r.txMcastPkts = &txMcastPkts
	return r
}

// Broadcast output packets
func (r ApiCountSiteSwOrGwPortsRequest) TxBcastPkts(txBcastPkts int32) ApiCountSiteSwOrGwPortsRequest {
	r.txBcastPkts = &txBcastPkts
	return r
}

// Multicast input packets
func (r ApiCountSiteSwOrGwPortsRequest) RxMcastPkts(rxMcastPkts int32) ApiCountSiteSwOrGwPortsRequest {
	r.rxMcastPkts = &rxMcastPkts
	return r
}

// Broadcast input packets
func (r ApiCountSiteSwOrGwPortsRequest) RxBcastPkts(rxBcastPkts int32) ApiCountSiteSwOrGwPortsRequest {
	r.rxBcastPkts = &rxBcastPkts
	return r
}

// port speed
func (r ApiCountSiteSwOrGwPortsRequest) Speed(speed int32) ApiCountSiteSwOrGwPortsRequest {
	r.speed = &speed
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountSiteSwOrGwPortsRequest) StpState(stpState CountSiteSwOrGwPortsStpState) ApiCountSiteSwOrGwPortsRequest {
	r.stpState = &stpState
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountSiteSwOrGwPortsRequest) StpRole(stpRole CountSiteSwOrGwPortsStpRole) ApiCountSiteSwOrGwPortsRequest {
	r.stpRole = &stpRole
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60; &amp;&amp; has Authenticator role
func (r ApiCountSiteSwOrGwPortsRequest) AuthState(authState CountSiteSwOrGwPortsAuthState) ApiCountSiteSwOrGwPortsRequest {
	r.authState = &authState
	return r
}

// indicates if interface is up
func (r ApiCountSiteSwOrGwPortsRequest) Up(up bool) ApiCountSiteSwOrGwPortsRequest {
	r.up = &up
	return r
}

func (r ApiCountSiteSwOrGwPortsRequest) Page(page int32) ApiCountSiteSwOrGwPortsRequest {
	r.page = &page
	return r
}

func (r ApiCountSiteSwOrGwPortsRequest) Limit(limit int32) ApiCountSiteSwOrGwPortsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountSiteSwOrGwPortsRequest) Start(start int32) ApiCountSiteSwOrGwPortsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountSiteSwOrGwPortsRequest) End(end int32) ApiCountSiteSwOrGwPortsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountSiteSwOrGwPortsRequest) Duration(duration string) ApiCountSiteSwOrGwPortsRequest {
	r.duration = &duration
	return r
}

func (r ApiCountSiteSwOrGwPortsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteSwOrGwPortsExecute(r)
}

/*
CountSiteSwOrGwPorts countSiteSwOrGwPorts

Count by Distinct Attributes of Switch/Gateway Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteSwOrGwPortsRequest
*/
func (a *SitesDevicesStatsAPIService) CountSiteSwOrGwPorts(ctx context.Context, siteId string) ApiCountSiteSwOrGwPortsRequest {
	return ApiCountSiteSwOrGwPortsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesStatsAPIService) CountSiteSwOrGwPortsExecute(r ApiCountSiteSwOrGwPortsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.CountSiteSwOrGwPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/ports/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue SitePortsCountDistinct = "mac"
		r.distinct = &defaultValue
	}
	if r.fullDuplex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_duplex", r.fullDuplex, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.neighborMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_mac", r.neighborMac, "")
	}
	if r.neighborPortDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_port_desc", r.neighborPortDesc, "")
	}
	if r.neighborSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_system_name", r.neighborSystemName, "")
	}
	if r.poeDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_disabled", r.poeDisabled, "")
	}
	if r.poeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_mode", r.poeMode, "")
	}
	if r.poeOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_on", r.poeOn, "")
	}
	if r.portId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_id", r.portId, "")
	}
	if r.portMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_mac", r.portMac, "")
	}
	if r.powerDraw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_draw", r.powerDraw, "")
	}
	if r.txPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_pkts", r.txPkts, "")
	}
	if r.rxPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_pkts", r.rxPkts, "")
	}
	if r.rxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bytes", r.rxBytes, "")
	}
	if r.txBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bps", r.txBps, "")
	}
	if r.rxBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bps", r.rxBps, "")
	}
	if r.txMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_mcast_pkts", r.txMcastPkts, "")
	}
	if r.txBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bcast_pkts", r.txBcastPkts, "")
	}
	if r.rxMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_mcast_pkts", r.rxMcastPkts, "")
	}
	if r.rxBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bcast_pkts", r.rxBcastPkts, "")
	}
	if r.speed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speed", r.speed, "")
	}
	if r.stpState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_state", r.stpState, "")
	}
	if r.stpRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_role", r.stpRole, "")
	}
	if r.authState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_state", r.authState, "")
	}
	if r.up != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up", r.up, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountSiteSwitchPortsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	distinct *SiteSwitchPortsCountDistinct
	fullDuplex *bool
	mac *string
	neighborMac *string
	neighborPortDesc *string
	neighborSystemName *string
	poeDisabled *bool
	poeMode *string
	poeOn *bool
	portId *string
	portMac *string
	powerDraw *float32
	txPkts *int32
	rxPkts *int32
	rxBytes *int32
	txBps *int32
	rxBps *int32
	txMcastPkts *int32
	txBcastPkts *int32
	rxMcastPkts *int32
	rxBcastPkts *int32
	speed *int32
	stpState *CountSiteSwitchPortsStpState
	stpRole *CountSiteSwitchPortsStpRole
	authState *CountSiteSwitchPortsAuthState
	up *bool
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountSiteSwitchPortsRequest) Distinct(distinct SiteSwitchPortsCountDistinct) ApiCountSiteSwitchPortsRequest {
	r.distinct = &distinct
	return r
}

// indicates full or half duplex
func (r ApiCountSiteSwitchPortsRequest) FullDuplex(fullDuplex bool) ApiCountSiteSwitchPortsRequest {
	r.fullDuplex = &fullDuplex
	return r
}

// device identifier
func (r ApiCountSiteSwitchPortsRequest) Mac(mac string) ApiCountSiteSwitchPortsRequest {
	r.mac = &mac
	return r
}

// Chassis identifier of the chassis type listed
func (r ApiCountSiteSwitchPortsRequest) NeighborMac(neighborMac string) ApiCountSiteSwitchPortsRequest {
	r.neighborMac = &neighborMac
	return r
}

// Description supplied by the system on the interface E.g. “GigabitEthernet2/0/39”
func (r ApiCountSiteSwitchPortsRequest) NeighborPortDesc(neighborPortDesc string) ApiCountSiteSwitchPortsRequest {
	r.neighborPortDesc = &neighborPortDesc
	return r
}

// Name supplied by the system on the interface E.g. neighbor system name E.g. “Kumar-Acc-SW.mist.local”
func (r ApiCountSiteSwitchPortsRequest) NeighborSystemName(neighborSystemName string) ApiCountSiteSwitchPortsRequest {
	r.neighborSystemName = &neighborSystemName
	return r
}

// is the POE configured not be disabled.
func (r ApiCountSiteSwitchPortsRequest) PoeDisabled(poeDisabled bool) ApiCountSiteSwitchPortsRequest {
	r.poeDisabled = &poeDisabled
	return r
}

// poe mode depending on class E.g. “802.3at”
func (r ApiCountSiteSwitchPortsRequest) PoeMode(poeMode string) ApiCountSiteSwitchPortsRequest {
	r.poeMode = &poeMode
	return r
}

// is the device attached to POE
func (r ApiCountSiteSwitchPortsRequest) PoeOn(poeOn bool) ApiCountSiteSwitchPortsRequest {
	r.poeOn = &poeOn
	return r
}

// interface name
func (r ApiCountSiteSwitchPortsRequest) PortId(portId string) ApiCountSiteSwitchPortsRequest {
	r.portId = &portId
	return r
}

// interface mac address
func (r ApiCountSiteSwitchPortsRequest) PortMac(portMac string) ApiCountSiteSwitchPortsRequest {
	r.portMac = &portMac
	return r
}

// Amount of power being used by the interface at the time the command is executed. Unit in watts.
func (r ApiCountSiteSwitchPortsRequest) PowerDraw(powerDraw float32) ApiCountSiteSwitchPortsRequest {
	r.powerDraw = &powerDraw
	return r
}

// Output packets
func (r ApiCountSiteSwitchPortsRequest) TxPkts(txPkts int32) ApiCountSiteSwitchPortsRequest {
	r.txPkts = &txPkts
	return r
}

// Input packets
func (r ApiCountSiteSwitchPortsRequest) RxPkts(rxPkts int32) ApiCountSiteSwitchPortsRequest {
	r.rxPkts = &rxPkts
	return r
}

// Input bytes
func (r ApiCountSiteSwitchPortsRequest) RxBytes(rxBytes int32) ApiCountSiteSwitchPortsRequest {
	r.rxBytes = &rxBytes
	return r
}

// Output rate
func (r ApiCountSiteSwitchPortsRequest) TxBps(txBps int32) ApiCountSiteSwitchPortsRequest {
	r.txBps = &txBps
	return r
}

// Input rate
func (r ApiCountSiteSwitchPortsRequest) RxBps(rxBps int32) ApiCountSiteSwitchPortsRequest {
	r.rxBps = &rxBps
	return r
}

// Multicast output packets
func (r ApiCountSiteSwitchPortsRequest) TxMcastPkts(txMcastPkts int32) ApiCountSiteSwitchPortsRequest {
	r.txMcastPkts = &txMcastPkts
	return r
}

// Broadcast output packets
func (r ApiCountSiteSwitchPortsRequest) TxBcastPkts(txBcastPkts int32) ApiCountSiteSwitchPortsRequest {
	r.txBcastPkts = &txBcastPkts
	return r
}

// Multicast input packets
func (r ApiCountSiteSwitchPortsRequest) RxMcastPkts(rxMcastPkts int32) ApiCountSiteSwitchPortsRequest {
	r.rxMcastPkts = &rxMcastPkts
	return r
}

// Broadcast input packets
func (r ApiCountSiteSwitchPortsRequest) RxBcastPkts(rxBcastPkts int32) ApiCountSiteSwitchPortsRequest {
	r.rxBcastPkts = &rxBcastPkts
	return r
}

// port speed
func (r ApiCountSiteSwitchPortsRequest) Speed(speed int32) ApiCountSiteSwitchPortsRequest {
	r.speed = &speed
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountSiteSwitchPortsRequest) StpState(stpState CountSiteSwitchPortsStpState) ApiCountSiteSwitchPortsRequest {
	r.stpState = &stpState
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountSiteSwitchPortsRequest) StpRole(stpRole CountSiteSwitchPortsStpRole) ApiCountSiteSwitchPortsRequest {
	r.stpRole = &stpRole
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountSiteSwitchPortsRequest) AuthState(authState CountSiteSwitchPortsAuthState) ApiCountSiteSwitchPortsRequest {
	r.authState = &authState
	return r
}

// indicates if interface is up
func (r ApiCountSiteSwitchPortsRequest) Up(up bool) ApiCountSiteSwitchPortsRequest {
	r.up = &up
	return r
}

func (r ApiCountSiteSwitchPortsRequest) Page(page int32) ApiCountSiteSwitchPortsRequest {
	r.page = &page
	return r
}

func (r ApiCountSiteSwitchPortsRequest) Limit(limit int32) ApiCountSiteSwitchPortsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountSiteSwitchPortsRequest) Start(start int32) ApiCountSiteSwitchPortsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountSiteSwitchPortsRequest) End(end int32) ApiCountSiteSwitchPortsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountSiteSwitchPortsRequest) Duration(duration string) ApiCountSiteSwitchPortsRequest {
	r.duration = &duration
	return r
}

func (r ApiCountSiteSwitchPortsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountSiteSwitchPortsExecute(r)
}

/*
CountSiteSwitchPorts countSiteSwitchPorts

Count by Distinct Attributes of Switch/Gateway Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiCountSiteSwitchPortsRequest
*/
func (a *SitesDevicesStatsAPIService) CountSiteSwitchPorts(ctx context.Context, siteId string) ApiCountSiteSwitchPortsRequest {
	return ApiCountSiteSwitchPortsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *SitesDevicesStatsAPIService) CountSiteSwitchPortsExecute(r ApiCountSiteSwitchPortsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.CountSiteSwitchPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/switch_ports/count"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue SiteSwitchPortsCountDistinct = "mac"
		r.distinct = &defaultValue
	}
	if r.fullDuplex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_duplex", r.fullDuplex, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.neighborMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_mac", r.neighborMac, "")
	}
	if r.neighborPortDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_port_desc", r.neighborPortDesc, "")
	}
	if r.neighborSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_system_name", r.neighborSystemName, "")
	}
	if r.poeDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_disabled", r.poeDisabled, "")
	}
	if r.poeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_mode", r.poeMode, "")
	}
	if r.poeOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_on", r.poeOn, "")
	}
	if r.portId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_id", r.portId, "")
	}
	if r.portMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_mac", r.portMac, "")
	}
	if r.powerDraw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_draw", r.powerDraw, "")
	}
	if r.txPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_pkts", r.txPkts, "")
	}
	if r.rxPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_pkts", r.rxPkts, "")
	}
	if r.rxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bytes", r.rxBytes, "")
	}
	if r.txBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bps", r.txBps, "")
	}
	if r.rxBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bps", r.rxBps, "")
	}
	if r.txMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_mcast_pkts", r.txMcastPkts, "")
	}
	if r.txBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bcast_pkts", r.txBcastPkts, "")
	}
	if r.rxMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_mcast_pkts", r.rxMcastPkts, "")
	}
	if r.rxBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bcast_pkts", r.rxBcastPkts, "")
	}
	if r.speed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speed", r.speed, "")
	}
	if r.stpState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_state", r.stpState, "")
	}
	if r.stpRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_role", r.stpRole, "")
	}
	if r.authState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_state", r.authState, "")
	}
	if r.up != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up", r.up, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteAllClientsStatsByDeviceRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	deviceId string
}

func (r ApiGetSiteAllClientsStatsByDeviceRequest) Execute() ([][]ClientWirelessStats, *http.Response, error) {
	return r.ApiService.GetSiteAllClientsStatsByDeviceExecute(r)
}

/*
GetSiteAllClientsStatsByDevice getSiteAllClientsStatsByDevice

Get wireless client stat by Device

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @return ApiGetSiteAllClientsStatsByDeviceRequest
*/
func (a *SitesDevicesStatsAPIService) GetSiteAllClientsStatsByDevice(ctx context.Context, siteId string, deviceId string) ApiGetSiteAllClientsStatsByDeviceRequest {
	return ApiGetSiteAllClientsStatsByDeviceRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return [][]ClientWirelessStats
func (a *SitesDevicesStatsAPIService) GetSiteAllClientsStatsByDeviceExecute(r ApiGetSiteAllClientsStatsByDeviceRequest) ([][]ClientWirelessStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  [][]ClientWirelessStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.GetSiteAllClientsStatsByDevice")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/devices/{device_id}/clients"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteDeviceStatsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	deviceId string
}

func (r ApiGetSiteDeviceStatsRequest) Execute() (*StatsDevice, *http.Response, error) {
	return r.ApiService.GetSiteDeviceStatsExecute(r)
}

/*
GetSiteDeviceStats getSiteDeviceStats

Get Site Device Stats Details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param deviceId
 @return ApiGetSiteDeviceStatsRequest
*/
func (a *SitesDevicesStatsAPIService) GetSiteDeviceStats(ctx context.Context, siteId string, deviceId string) ApiGetSiteDeviceStatsRequest {
	return ApiGetSiteDeviceStatsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		deviceId: deviceId,
	}
}

// Execute executes the request
//  @return StatsDevice
func (a *SitesDevicesStatsAPIService) GetSiteDeviceStatsExecute(r ApiGetSiteDeviceStatsRequest) (*StatsDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *StatsDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.GetSiteDeviceStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/devices/{device_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"device_id"+"}", url.PathEscape(parameterValueToString(r.deviceId, "deviceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteGatewayMetricsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
}

func (r ApiGetSiteGatewayMetricsRequest) Execute() (*GatewayMetrics, *http.Response, error) {
	return r.ApiService.GetSiteGatewayMetricsExecute(r)
}

/*
GetSiteGatewayMetrics getSiteGatewayMetrics

Get Site Gateway Metrics

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiGetSiteGatewayMetricsRequest
*/
func (a *SitesDevicesStatsAPIService) GetSiteGatewayMetrics(ctx context.Context, siteId string) ApiGetSiteGatewayMetricsRequest {
	return ApiGetSiteGatewayMetricsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return GatewayMetrics
func (a *SitesDevicesStatsAPIService) GetSiteGatewayMetricsExecute(r ApiGetSiteGatewayMetricsRequest) (*GatewayMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *GatewayMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.GetSiteGatewayMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/gateways/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteMxEdgeStatsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	mxedgeId string
	start *int32
	end *int32
	duration *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteMxEdgeStatsRequest) Start(start int32) ApiGetSiteMxEdgeStatsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteMxEdgeStatsRequest) End(end int32) ApiGetSiteMxEdgeStatsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteMxEdgeStatsRequest) Duration(duration string) ApiGetSiteMxEdgeStatsRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteMxEdgeStatsRequest) Execute() (*MxedgeStats, *http.Response, error) {
	return r.ApiService.GetSiteMxEdgeStatsExecute(r)
}

/*
GetSiteMxEdgeStats getSiteMxEdgeStats

Get One Site MxEdge Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param mxedgeId
 @return ApiGetSiteMxEdgeStatsRequest
*/
func (a *SitesDevicesStatsAPIService) GetSiteMxEdgeStats(ctx context.Context, siteId string, mxedgeId string) ApiGetSiteMxEdgeStatsRequest {
	return ApiGetSiteMxEdgeStatsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		mxedgeId: mxedgeId,
	}
}

// Execute executes the request
//  @return MxedgeStats
func (a *SitesDevicesStatsAPIService) GetSiteMxEdgeStatsExecute(r ApiGetSiteMxEdgeStatsRequest) (*MxedgeStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MxedgeStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.GetSiteMxEdgeStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/mxedges/{mxedge_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"mxedge_id"+"}", url.PathEscape(parameterValueToString(r.mxedgeId, "mxedgeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSiteDevicesStatsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	type_ *DeviceTypeWithAll
	status *StatDeviceStatusFilter
	page *int32
	limit *int32
}

func (r ApiListSiteDevicesStatsRequest) Type_(type_ DeviceTypeWithAll) ApiListSiteDevicesStatsRequest {
	r.type_ = &type_
	return r
}

func (r ApiListSiteDevicesStatsRequest) Status(status StatDeviceStatusFilter) ApiListSiteDevicesStatsRequest {
	r.status = &status
	return r
}

func (r ApiListSiteDevicesStatsRequest) Page(page int32) ApiListSiteDevicesStatsRequest {
	r.page = &page
	return r
}

func (r ApiListSiteDevicesStatsRequest) Limit(limit int32) ApiListSiteDevicesStatsRequest {
	r.limit = &limit
	return r
}

func (r ApiListSiteDevicesStatsRequest) Execute() ([]ResponseStatsDevice, *http.Response, error) {
	return r.ApiService.ListSiteDevicesStatsExecute(r)
}

/*
ListSiteDevicesStats listSiteDevicesStats

Get List of Site Devices Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiListSiteDevicesStatsRequest
*/
func (a *SitesDevicesStatsAPIService) ListSiteDevicesStats(ctx context.Context, siteId string) ApiListSiteDevicesStatsRequest {
	return ApiListSiteDevicesStatsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []ResponseStatsDevice
func (a *SitesDevicesStatsAPIService) ListSiteDevicesStatsExecute(r ApiListSiteDevicesStatsRequest) ([]ResponseStatsDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ResponseStatsDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.ListSiteDevicesStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceTypeWithAll = "ap"
		r.type_ = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	} else {
		var defaultValue StatDeviceStatusFilter = "all"
		r.status = &defaultValue
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListSiteMxEdgesStatsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiListSiteMxEdgesStatsRequest) Page(page int32) ApiListSiteMxEdgesStatsRequest {
	r.page = &page
	return r
}

func (r ApiListSiteMxEdgesStatsRequest) Limit(limit int32) ApiListSiteMxEdgesStatsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiListSiteMxEdgesStatsRequest) Start(start int32) ApiListSiteMxEdgesStatsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiListSiteMxEdgesStatsRequest) End(end int32) ApiListSiteMxEdgesStatsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiListSiteMxEdgesStatsRequest) Duration(duration string) ApiListSiteMxEdgesStatsRequest {
	r.duration = &duration
	return r
}

func (r ApiListSiteMxEdgesStatsRequest) Execute() ([]MxedgeStats, *http.Response, error) {
	return r.ApiService.ListSiteMxEdgesStatsExecute(r)
}

/*
ListSiteMxEdgesStats listSiteMxEdgesStats

Get List of Site MxEdges Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiListSiteMxEdgesStatsRequest
*/
func (a *SitesDevicesStatsAPIService) ListSiteMxEdgesStats(ctx context.Context, siteId string) ApiListSiteMxEdgesStatsRequest {
	return ApiListSiteMxEdgesStatsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return []MxedgeStats
func (a *SitesDevicesStatsAPIService) ListSiteMxEdgesStatsExecute(r ApiListSiteMxEdgesStatsRequest) ([]MxedgeStats, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []MxedgeStats
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.ListSiteMxEdgesStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/mxedges"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSiteBgpStatsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
}

func (r ApiSearchSiteBgpStatsRequest) Execute() (*ResponseSearchBgps, *http.Response, error) {
	return r.ApiService.SearchSiteBgpStatsExecute(r)
}

/*
SearchSiteBgpStats searchSiteBgpStats

Search BGP Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteBgpStatsRequest
*/
func (a *SitesDevicesStatsAPIService) SearchSiteBgpStats(ctx context.Context, siteId string) ApiSearchSiteBgpStatsRequest {
	return ApiSearchSiteBgpStatsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseSearchBgps
func (a *SitesDevicesStatsAPIService) SearchSiteBgpStatsExecute(r ApiSearchSiteBgpStatsRequest) (*ResponseSearchBgps, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseSearchBgps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.SearchSiteBgpStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/bgp_peers/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSiteSwOrGwPortsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	fullDuplex *bool
	mac *string
	deviceType *SearchSiteSwOrGwPortsDeviceType
	neighborMac *string
	neighborPortDesc *string
	neighborSystemName *string
	poeDisabled *bool
	poeMode *string
	poeOn *bool
	portId *string
	portMac *string
	powerDraw *float32
	txPkts *int32
	rxPkts *int32
	rxBytes *int32
	txBps *int32
	rxBps *int32
	txErrors *int32
	rxErrors *int32
	txMcastPkts *int32
	txBcastPkts *int32
	rxMcastPkts *int32
	rxBcastPkts *int32
	speed *int32
	macLimit *int32
	macCount *int32
	up *bool
	active *bool
	jitter *float32
	loss *float32
	latency *float32
	stpState *SearchSiteSwOrGwPortsStpState
	stpRole *SearchSiteSwOrGwPortsStpRole
	xcvrPartNumber *string
	authState *SearchSiteSwOrGwPortsAuthState
	lteImsi *string
	lteIccid *string
	lteImei *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

// indicates full or half duplex
func (r ApiSearchSiteSwOrGwPortsRequest) FullDuplex(fullDuplex bool) ApiSearchSiteSwOrGwPortsRequest {
	r.fullDuplex = &fullDuplex
	return r
}

// device identifier
func (r ApiSearchSiteSwOrGwPortsRequest) Mac(mac string) ApiSearchSiteSwOrGwPortsRequest {
	r.mac = &mac
	return r
}

// device type
func (r ApiSearchSiteSwOrGwPortsRequest) DeviceType(deviceType SearchSiteSwOrGwPortsDeviceType) ApiSearchSiteSwOrGwPortsRequest {
	r.deviceType = &deviceType
	return r
}

// Chassis identifier of the chassis type listed
func (r ApiSearchSiteSwOrGwPortsRequest) NeighborMac(neighborMac string) ApiSearchSiteSwOrGwPortsRequest {
	r.neighborMac = &neighborMac
	return r
}

// Description supplied by the system on the interface E.g. “GigabitEthernet2/0/39”
func (r ApiSearchSiteSwOrGwPortsRequest) NeighborPortDesc(neighborPortDesc string) ApiSearchSiteSwOrGwPortsRequest {
	r.neighborPortDesc = &neighborPortDesc
	return r
}

// Name supplied by the system on the interface E.g. neighbor system name E.g. “Kumar-Acc-SW.mist.local”
func (r ApiSearchSiteSwOrGwPortsRequest) NeighborSystemName(neighborSystemName string) ApiSearchSiteSwOrGwPortsRequest {
	r.neighborSystemName = &neighborSystemName
	return r
}

// is the POE configured not be disabled.
func (r ApiSearchSiteSwOrGwPortsRequest) PoeDisabled(poeDisabled bool) ApiSearchSiteSwOrGwPortsRequest {
	r.poeDisabled = &poeDisabled
	return r
}

// poe mode depending on class E.g. “802.3at”
func (r ApiSearchSiteSwOrGwPortsRequest) PoeMode(poeMode string) ApiSearchSiteSwOrGwPortsRequest {
	r.poeMode = &poeMode
	return r
}

// is the device attached to POE
func (r ApiSearchSiteSwOrGwPortsRequest) PoeOn(poeOn bool) ApiSearchSiteSwOrGwPortsRequest {
	r.poeOn = &poeOn
	return r
}

// interface name
func (r ApiSearchSiteSwOrGwPortsRequest) PortId(portId string) ApiSearchSiteSwOrGwPortsRequest {
	r.portId = &portId
	return r
}

// interface mac address
func (r ApiSearchSiteSwOrGwPortsRequest) PortMac(portMac string) ApiSearchSiteSwOrGwPortsRequest {
	r.portMac = &portMac
	return r
}

// Amount of power being used by the interface at the time the command is executed. Unit in watts.
func (r ApiSearchSiteSwOrGwPortsRequest) PowerDraw(powerDraw float32) ApiSearchSiteSwOrGwPortsRequest {
	r.powerDraw = &powerDraw
	return r
}

// Output packets
func (r ApiSearchSiteSwOrGwPortsRequest) TxPkts(txPkts int32) ApiSearchSiteSwOrGwPortsRequest {
	r.txPkts = &txPkts
	return r
}

// Input packets
func (r ApiSearchSiteSwOrGwPortsRequest) RxPkts(rxPkts int32) ApiSearchSiteSwOrGwPortsRequest {
	r.rxPkts = &rxPkts
	return r
}

// Input bytes
func (r ApiSearchSiteSwOrGwPortsRequest) RxBytes(rxBytes int32) ApiSearchSiteSwOrGwPortsRequest {
	r.rxBytes = &rxBytes
	return r
}

// Output rate
func (r ApiSearchSiteSwOrGwPortsRequest) TxBps(txBps int32) ApiSearchSiteSwOrGwPortsRequest {
	r.txBps = &txBps
	return r
}

// Input rate
func (r ApiSearchSiteSwOrGwPortsRequest) RxBps(rxBps int32) ApiSearchSiteSwOrGwPortsRequest {
	r.rxBps = &rxBps
	return r
}

// Output errors
func (r ApiSearchSiteSwOrGwPortsRequest) TxErrors(txErrors int32) ApiSearchSiteSwOrGwPortsRequest {
	r.txErrors = &txErrors
	return r
}

// Input errors
func (r ApiSearchSiteSwOrGwPortsRequest) RxErrors(rxErrors int32) ApiSearchSiteSwOrGwPortsRequest {
	r.rxErrors = &rxErrors
	return r
}

// Multicast output packets
func (r ApiSearchSiteSwOrGwPortsRequest) TxMcastPkts(txMcastPkts int32) ApiSearchSiteSwOrGwPortsRequest {
	r.txMcastPkts = &txMcastPkts
	return r
}

// Broadcast output packets
func (r ApiSearchSiteSwOrGwPortsRequest) TxBcastPkts(txBcastPkts int32) ApiSearchSiteSwOrGwPortsRequest {
	r.txBcastPkts = &txBcastPkts
	return r
}

// Multicast input packets
func (r ApiSearchSiteSwOrGwPortsRequest) RxMcastPkts(rxMcastPkts int32) ApiSearchSiteSwOrGwPortsRequest {
	r.rxMcastPkts = &rxMcastPkts
	return r
}

// Broadcast input packets
func (r ApiSearchSiteSwOrGwPortsRequest) RxBcastPkts(rxBcastPkts int32) ApiSearchSiteSwOrGwPortsRequest {
	r.rxBcastPkts = &rxBcastPkts
	return r
}

// port speed
func (r ApiSearchSiteSwOrGwPortsRequest) Speed(speed int32) ApiSearchSiteSwOrGwPortsRequest {
	r.speed = &speed
	return r
}

// Limit on number of dynamically learned macs
func (r ApiSearchSiteSwOrGwPortsRequest) MacLimit(macLimit int32) ApiSearchSiteSwOrGwPortsRequest {
	r.macLimit = &macLimit
	return r
}

// Number of mac addresses in the forwarding table
func (r ApiSearchSiteSwOrGwPortsRequest) MacCount(macCount int32) ApiSearchSiteSwOrGwPortsRequest {
	r.macCount = &macCount
	return r
}

// indicates if interface is up
func (r ApiSearchSiteSwOrGwPortsRequest) Up(up bool) ApiSearchSiteSwOrGwPortsRequest {
	r.up = &up
	return r
}

// indicates if interface is active/inactive
func (r ApiSearchSiteSwOrGwPortsRequest) Active(active bool) ApiSearchSiteSwOrGwPortsRequest {
	r.active = &active
	return r
}

// Last sampled jitter of the interface
func (r ApiSearchSiteSwOrGwPortsRequest) Jitter(jitter float32) ApiSearchSiteSwOrGwPortsRequest {
	r.jitter = &jitter
	return r
}

// Last sampled loss of the interface
func (r ApiSearchSiteSwOrGwPortsRequest) Loss(loss float32) ApiSearchSiteSwOrGwPortsRequest {
	r.loss = &loss
	return r
}

// Last sampled latency of the interface
func (r ApiSearchSiteSwOrGwPortsRequest) Latency(latency float32) ApiSearchSiteSwOrGwPortsRequest {
	r.latency = &latency
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiSearchSiteSwOrGwPortsRequest) StpState(stpState SearchSiteSwOrGwPortsStpState) ApiSearchSiteSwOrGwPortsRequest {
	r.stpState = &stpState
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiSearchSiteSwOrGwPortsRequest) StpRole(stpRole SearchSiteSwOrGwPortsStpRole) ApiSearchSiteSwOrGwPortsRequest {
	r.stpRole = &stpRole
	return r
}

// Optic Slot Partnumber, Check for null/empty
func (r ApiSearchSiteSwOrGwPortsRequest) XcvrPartNumber(xcvrPartNumber string) ApiSearchSiteSwOrGwPortsRequest {
	r.xcvrPartNumber = &xcvrPartNumber
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60; &amp;&amp; has Authenticator role
func (r ApiSearchSiteSwOrGwPortsRequest) AuthState(authState SearchSiteSwOrGwPortsAuthState) ApiSearchSiteSwOrGwPortsRequest {
	r.authState = &authState
	return r
}

// LTE IMSI value, Check for null/empty
func (r ApiSearchSiteSwOrGwPortsRequest) LteImsi(lteImsi string) ApiSearchSiteSwOrGwPortsRequest {
	r.lteImsi = &lteImsi
	return r
}

// LTE ICCID value, Check for null/empty
func (r ApiSearchSiteSwOrGwPortsRequest) LteIccid(lteIccid string) ApiSearchSiteSwOrGwPortsRequest {
	r.lteIccid = &lteIccid
	return r
}

// LTE IMEI value, Check for null/empty
func (r ApiSearchSiteSwOrGwPortsRequest) LteImei(lteImei string) ApiSearchSiteSwOrGwPortsRequest {
	r.lteImei = &lteImei
	return r
}

func (r ApiSearchSiteSwOrGwPortsRequest) Limit(limit int32) ApiSearchSiteSwOrGwPortsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchSiteSwOrGwPortsRequest) Start(start int32) ApiSearchSiteSwOrGwPortsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchSiteSwOrGwPortsRequest) End(end int32) ApiSearchSiteSwOrGwPortsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchSiteSwOrGwPortsRequest) Duration(duration string) ApiSearchSiteSwOrGwPortsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchSiteSwOrGwPortsRequest) Execute() (*ResponseSwitchPortSearch, *http.Response, error) {
	return r.ApiService.SearchSiteSwOrGwPortsExecute(r)
}

/*
SearchSiteSwOrGwPorts searchSiteSwOrGwPorts

Search Switch / Gateway Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteSwOrGwPortsRequest
*/
func (a *SitesDevicesStatsAPIService) SearchSiteSwOrGwPorts(ctx context.Context, siteId string) ApiSearchSiteSwOrGwPortsRequest {
	return ApiSearchSiteSwOrGwPortsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseSwitchPortSearch
func (a *SitesDevicesStatsAPIService) SearchSiteSwOrGwPortsExecute(r ApiSearchSiteSwOrGwPortsRequest) (*ResponseSwitchPortSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseSwitchPortSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.SearchSiteSwOrGwPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/ports/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fullDuplex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_duplex", r.fullDuplex, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.deviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", r.deviceType, "")
	}
	if r.neighborMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_mac", r.neighborMac, "")
	}
	if r.neighborPortDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_port_desc", r.neighborPortDesc, "")
	}
	if r.neighborSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_system_name", r.neighborSystemName, "")
	}
	if r.poeDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_disabled", r.poeDisabled, "")
	}
	if r.poeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_mode", r.poeMode, "")
	}
	if r.poeOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_on", r.poeOn, "")
	}
	if r.portId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_id", r.portId, "")
	}
	if r.portMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_mac", r.portMac, "")
	}
	if r.powerDraw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_draw", r.powerDraw, "")
	}
	if r.txPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_pkts", r.txPkts, "")
	}
	if r.rxPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_pkts", r.rxPkts, "")
	}
	if r.rxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bytes", r.rxBytes, "")
	}
	if r.txBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bps", r.txBps, "")
	}
	if r.rxBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bps", r.rxBps, "")
	}
	if r.txErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_errors", r.txErrors, "")
	}
	if r.rxErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_errors", r.rxErrors, "")
	}
	if r.txMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_mcast_pkts", r.txMcastPkts, "")
	}
	if r.txBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bcast_pkts", r.txBcastPkts, "")
	}
	if r.rxMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_mcast_pkts", r.rxMcastPkts, "")
	}
	if r.rxBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bcast_pkts", r.rxBcastPkts, "")
	}
	if r.speed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speed", r.speed, "")
	}
	if r.macLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac_limit", r.macLimit, "")
	}
	if r.macCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac_count", r.macCount, "")
	}
	if r.up != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up", r.up, "")
	}
	if r.active != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "active", r.active, "")
	}
	if r.jitter != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "jitter", r.jitter, "")
	}
	if r.loss != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "loss", r.loss, "")
	}
	if r.latency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "latency", r.latency, "")
	}
	if r.stpState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_state", r.stpState, "")
	}
	if r.stpRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_role", r.stpRole, "")
	}
	if r.xcvrPartNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "xcvr_part_number", r.xcvrPartNumber, "")
	}
	if r.authState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_state", r.authState, "")
	}
	if r.lteImsi != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lte_imsi", r.lteImsi, "")
	}
	if r.lteIccid != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lte_iccid", r.lteIccid, "")
	}
	if r.lteImei != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lte_imei", r.lteImei, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchSiteSwitchPortsRequest struct {
	ctx context.Context
	ApiService SitesDevicesStatsAPI
	siteId string
	fullDuplex *bool
	mac *string
	neighborMac *string
	neighborPortDesc *string
	neighborSystemName *string
	poeDisabled *bool
	poeMode *string
	poeOn *bool
	portId *string
	portMac *string
	powerDraw *float32
	txPkts *int32
	rxPkts *int32
	rxBytes *int32
	txBps *int32
	rxBps *int32
	txMcastPkts *int32
	txBcastPkts *int32
	rxMcastPkts *int32
	rxBcastPkts *int32
	speed *int32
	stpState *SearchSiteSwitchPortsStpState
	stpRole *SearchSiteSwitchPortsStpRole
	authState *SearchSiteSwitchPortsAuthState
	up *bool
	limit *int32
	start *int32
	end *int32
	duration *string
}

// indicates full or half duplex
func (r ApiSearchSiteSwitchPortsRequest) FullDuplex(fullDuplex bool) ApiSearchSiteSwitchPortsRequest {
	r.fullDuplex = &fullDuplex
	return r
}

// device identifier
func (r ApiSearchSiteSwitchPortsRequest) Mac(mac string) ApiSearchSiteSwitchPortsRequest {
	r.mac = &mac
	return r
}

// Chassis identifier of the chassis type listed
func (r ApiSearchSiteSwitchPortsRequest) NeighborMac(neighborMac string) ApiSearchSiteSwitchPortsRequest {
	r.neighborMac = &neighborMac
	return r
}

// Description supplied by the system on the interface E.g. “GigabitEthernet2/0/39”
func (r ApiSearchSiteSwitchPortsRequest) NeighborPortDesc(neighborPortDesc string) ApiSearchSiteSwitchPortsRequest {
	r.neighborPortDesc = &neighborPortDesc
	return r
}

// Name supplied by the system on the interface E.g. neighbor system name E.g. “Kumar-Acc-SW.mist.local”
func (r ApiSearchSiteSwitchPortsRequest) NeighborSystemName(neighborSystemName string) ApiSearchSiteSwitchPortsRequest {
	r.neighborSystemName = &neighborSystemName
	return r
}

// is the POE configured not be disabled.
func (r ApiSearchSiteSwitchPortsRequest) PoeDisabled(poeDisabled bool) ApiSearchSiteSwitchPortsRequest {
	r.poeDisabled = &poeDisabled
	return r
}

// poe mode depending on class E.g. “802.3at”
func (r ApiSearchSiteSwitchPortsRequest) PoeMode(poeMode string) ApiSearchSiteSwitchPortsRequest {
	r.poeMode = &poeMode
	return r
}

// is the device attached to POE
func (r ApiSearchSiteSwitchPortsRequest) PoeOn(poeOn bool) ApiSearchSiteSwitchPortsRequest {
	r.poeOn = &poeOn
	return r
}

// interface name
func (r ApiSearchSiteSwitchPortsRequest) PortId(portId string) ApiSearchSiteSwitchPortsRequest {
	r.portId = &portId
	return r
}

// interface mac address
func (r ApiSearchSiteSwitchPortsRequest) PortMac(portMac string) ApiSearchSiteSwitchPortsRequest {
	r.portMac = &portMac
	return r
}

// Amount of power being used by the interface at the time the command is executed. Unit in watts.
func (r ApiSearchSiteSwitchPortsRequest) PowerDraw(powerDraw float32) ApiSearchSiteSwitchPortsRequest {
	r.powerDraw = &powerDraw
	return r
}

// Output packets
func (r ApiSearchSiteSwitchPortsRequest) TxPkts(txPkts int32) ApiSearchSiteSwitchPortsRequest {
	r.txPkts = &txPkts
	return r
}

// Input packets
func (r ApiSearchSiteSwitchPortsRequest) RxPkts(rxPkts int32) ApiSearchSiteSwitchPortsRequest {
	r.rxPkts = &rxPkts
	return r
}

// Input bytes
func (r ApiSearchSiteSwitchPortsRequest) RxBytes(rxBytes int32) ApiSearchSiteSwitchPortsRequest {
	r.rxBytes = &rxBytes
	return r
}

// Output rate
func (r ApiSearchSiteSwitchPortsRequest) TxBps(txBps int32) ApiSearchSiteSwitchPortsRequest {
	r.txBps = &txBps
	return r
}

// Input rate
func (r ApiSearchSiteSwitchPortsRequest) RxBps(rxBps int32) ApiSearchSiteSwitchPortsRequest {
	r.rxBps = &rxBps
	return r
}

// Multicast output packets
func (r ApiSearchSiteSwitchPortsRequest) TxMcastPkts(txMcastPkts int32) ApiSearchSiteSwitchPortsRequest {
	r.txMcastPkts = &txMcastPkts
	return r
}

// Broadcast output packets
func (r ApiSearchSiteSwitchPortsRequest) TxBcastPkts(txBcastPkts int32) ApiSearchSiteSwitchPortsRequest {
	r.txBcastPkts = &txBcastPkts
	return r
}

// Multicast input packets
func (r ApiSearchSiteSwitchPortsRequest) RxMcastPkts(rxMcastPkts int32) ApiSearchSiteSwitchPortsRequest {
	r.rxMcastPkts = &rxMcastPkts
	return r
}

// Broadcast input packets
func (r ApiSearchSiteSwitchPortsRequest) RxBcastPkts(rxBcastPkts int32) ApiSearchSiteSwitchPortsRequest {
	r.rxBcastPkts = &rxBcastPkts
	return r
}

// port speed
func (r ApiSearchSiteSwitchPortsRequest) Speed(speed int32) ApiSearchSiteSwitchPortsRequest {
	r.speed = &speed
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiSearchSiteSwitchPortsRequest) StpState(stpState SearchSiteSwitchPortsStpState) ApiSearchSiteSwitchPortsRequest {
	r.stpState = &stpState
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiSearchSiteSwitchPortsRequest) StpRole(stpRole SearchSiteSwitchPortsStpRole) ApiSearchSiteSwitchPortsRequest {
	r.stpRole = &stpRole
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60; &amp;&amp; has Authenticator role
func (r ApiSearchSiteSwitchPortsRequest) AuthState(authState SearchSiteSwitchPortsAuthState) ApiSearchSiteSwitchPortsRequest {
	r.authState = &authState
	return r
}

// indicates if interface is up
func (r ApiSearchSiteSwitchPortsRequest) Up(up bool) ApiSearchSiteSwitchPortsRequest {
	r.up = &up
	return r
}

func (r ApiSearchSiteSwitchPortsRequest) Limit(limit int32) ApiSearchSiteSwitchPortsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchSiteSwitchPortsRequest) Start(start int32) ApiSearchSiteSwitchPortsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchSiteSwitchPortsRequest) End(end int32) ApiSearchSiteSwitchPortsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchSiteSwitchPortsRequest) Duration(duration string) ApiSearchSiteSwitchPortsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchSiteSwitchPortsRequest) Execute() (*ResponseSwitchPortSearch, *http.Response, error) {
	return r.ApiService.SearchSiteSwitchPortsExecute(r)
}

/*
SearchSiteSwitchPorts searchSiteSwitchPorts

Search Switch / Gateway Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @return ApiSearchSiteSwitchPortsRequest
*/
func (a *SitesDevicesStatsAPIService) SearchSiteSwitchPorts(ctx context.Context, siteId string) ApiSearchSiteSwitchPortsRequest {
	return ApiSearchSiteSwitchPortsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
	}
}

// Execute executes the request
//  @return ResponseSwitchPortSearch
func (a *SitesDevicesStatsAPIService) SearchSiteSwitchPortsExecute(r ApiSearchSiteSwitchPortsRequest) (*ResponseSwitchPortSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseSwitchPortSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesDevicesStatsAPIService.SearchSiteSwitchPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/stats/switch_ports/search"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fullDuplex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_duplex", r.fullDuplex, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.neighborMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_mac", r.neighborMac, "")
	}
	if r.neighborPortDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_port_desc", r.neighborPortDesc, "")
	}
	if r.neighborSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_system_name", r.neighborSystemName, "")
	}
	if r.poeDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_disabled", r.poeDisabled, "")
	}
	if r.poeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_mode", r.poeMode, "")
	}
	if r.poeOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_on", r.poeOn, "")
	}
	if r.portId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_id", r.portId, "")
	}
	if r.portMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_mac", r.portMac, "")
	}
	if r.powerDraw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_draw", r.powerDraw, "")
	}
	if r.txPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_pkts", r.txPkts, "")
	}
	if r.rxPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_pkts", r.rxPkts, "")
	}
	if r.rxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bytes", r.rxBytes, "")
	}
	if r.txBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bps", r.txBps, "")
	}
	if r.rxBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bps", r.rxBps, "")
	}
	if r.txMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_mcast_pkts", r.txMcastPkts, "")
	}
	if r.txBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bcast_pkts", r.txBcastPkts, "")
	}
	if r.rxMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_mcast_pkts", r.rxMcastPkts, "")
	}
	if r.rxBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bcast_pkts", r.rxBcastPkts, "")
	}
	if r.speed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speed", r.speed, "")
	}
	if r.stpState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_state", r.stpState, "")
	}
	if r.stpRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_role", r.stpRole, "")
	}
	if r.authState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_state", r.authState, "")
	}
	if r.up != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up", r.up, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
