/*
Mist API

> Version: **2406.1.14** > > Date: **July 3, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.14
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type SitesSLEsAPI interface {

	/*
	GetSiteSleClassifierDetails getSiteSleClassifierDetails

	Get SLE classifier details

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@param classifier
	@return ApiGetSiteSleClassifierDetailsRequest
	*/
	GetSiteSleClassifierDetails(ctx context.Context, siteId string, scope SleSummaryScope, scopeId string, metric string, classifier string) ApiGetSiteSleClassifierDetailsRequest

	// GetSiteSleClassifierDetailsExecute executes the request
	//  @return SleClassifierSummary
	GetSiteSleClassifierDetailsExecute(r ApiGetSiteSleClassifierDetailsRequest) (*SleClassifierSummary, *http.Response, error)

	/*
	GetSiteSleHistogram getSiteSleHistogram

	Get the histogram for the SLE metric

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleHistogramRequest
	*/
	GetSiteSleHistogram(ctx context.Context, siteId string, scope SiteSleHistogramScopeParameters, scopeId string, metric string) ApiGetSiteSleHistogramRequest

	// GetSiteSleHistogramExecute executes the request
	//  @return SleHistogram
	GetSiteSleHistogramExecute(r ApiGetSiteSleHistogramRequest) (*SleHistogram, *http.Response, error)

	/*
	GetSiteSleImpactSummary getSiteSleImpactSummary

	Get impact summary counts optionally filtered by classifier and failure type
 
* Wireless SLE Fields: `wlan`, `device_type`, `device_os` ,`band`, `ap`, `server`, `mxedge`
* Wired SLE Fields: `switch`, `client`, `vlan`, `interface`, `chassis`
* WAN SLE Fields: `gateway`, `client`, `interface`, `chassis`, `peer_path`, `gateway_zones`

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactSummaryRequest
	*/
	GetSiteSleImpactSummary(ctx context.Context, siteId string, scope SiteSleImpactSummaryScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactSummaryRequest

	// GetSiteSleImpactSummaryExecute executes the request
	//  @return SleImpactSummary
	GetSiteSleImpactSummaryExecute(r ApiGetSiteSleImpactSummaryRequest) (*SleImpactSummary, *http.Response, error)

	/*
	GetSiteSleImpactedApplications getSiteSleImpactedApplications

	For WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedApplicationsRequest
	*/
	GetSiteSleImpactedApplications(ctx context.Context, siteId string, scope SiteSleScope, scopeId string, metric string) ApiGetSiteSleImpactedApplicationsRequest

	// GetSiteSleImpactedApplicationsExecute executes the request
	//  @return SleImpactedApplications
	GetSiteSleImpactedApplicationsExecute(r ApiGetSiteSleImpactedApplicationsRequest) (*SleImpactedApplications, *http.Response, error)

	/*
	GetSiteSleImpactedAps getSiteSleImpactedAps

	For Wireless SLEs. Get list of impacted APs optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedApsRequest
	*/
	GetSiteSleImpactedAps(ctx context.Context, siteId string, scope SiteSleImpactedApsScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedApsRequest

	// GetSiteSleImpactedApsExecute executes the request
	//  @return SleImpactedAps
	GetSiteSleImpactedApsExecute(r ApiGetSiteSleImpactedApsRequest) (*SleImpactedAps, *http.Response, error)

	/*
	GetSiteSleImpactedChassis getSiteSleImpactedChassis

	For Wired and WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedChassisRequest
	*/
	GetSiteSleImpactedChassis(ctx context.Context, siteId string, scope SiteSleImpactedChassisScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedChassisRequest

	// GetSiteSleImpactedChassisExecute executes the request
	//  @return SleImpactedChassis
	GetSiteSleImpactedChassisExecute(r ApiGetSiteSleImpactedChassisRequest) (*SleImpactedChassis, *http.Response, error)

	/*
	GetSiteSleImpactedGateways getSiteSleImpactedGateways

	For WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedGatewaysRequest
	*/
	GetSiteSleImpactedGateways(ctx context.Context, siteId string, scope SiteSleImpactedGatewaysScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedGatewaysRequest

	// GetSiteSleImpactedGatewaysExecute executes the request
	//  @return SleImpactedGateways
	GetSiteSleImpactedGatewaysExecute(r ApiGetSiteSleImpactedGatewaysRequest) (*SleImpactedGateways, *http.Response, error)

	/*
	GetSiteSleImpactedInterfaces getSiteSleImpactedInterfaces

	For Wired and WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedInterfacesRequest
	*/
	GetSiteSleImpactedInterfaces(ctx context.Context, siteId string, scope SiteSleImpactedInterfacesScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedInterfacesRequest

	// GetSiteSleImpactedInterfacesExecute executes the request
	//  @return SleImpactedInterfaces
	GetSiteSleImpactedInterfacesExecute(r ApiGetSiteSleImpactedInterfacesRequest) (*SleImpactedInterfaces, *http.Response, error)

	/*
	GetSiteSleImpactedSwitches getSiteSleImpactedSwitches

	For Wired SLEs. Get list of impacted switches optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedSwitchesRequest
	*/
	GetSiteSleImpactedSwitches(ctx context.Context, siteId string, scope SiteSleImpactedSwitchesScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedSwitchesRequest

	// GetSiteSleImpactedSwitchesExecute executes the request
	//  @return SleImpactedSwitches
	GetSiteSleImpactedSwitchesExecute(r ApiGetSiteSleImpactedSwitchesRequest) (*SleImpactedSwitches, *http.Response, error)

	/*
	GetSiteSleImpactedWiredClients getSiteSleImpactedWiredClients

	For Wired SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedWiredClientsRequest
	*/
	GetSiteSleImpactedWiredClients(ctx context.Context, siteId string, scope SiteSleImpactedClientsScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedWiredClientsRequest

	// GetSiteSleImpactedWiredClientsExecute executes the request
	//  @return SleImpactedClients
	GetSiteSleImpactedWiredClientsExecute(r ApiGetSiteSleImpactedWiredClientsRequest) (*SleImpactedClients, *http.Response, error)

	/*
	GetSiteSleImpactedWirelessClients getSiteSleImpactedWirelessClients

	For Wireless SLEs. Get list of impacted wireless users optionally filtered by classifier and failure type

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleImpactedWirelessClientsRequest
	*/
	GetSiteSleImpactedWirelessClients(ctx context.Context, siteId string, scope SiteSleImpactedUsersScopeParameter, scopeId string, metric string) ApiGetSiteSleImpactedWirelessClientsRequest

	// GetSiteSleImpactedWirelessClientsExecute executes the request
	//  @return SleImpactedUsers
	GetSiteSleImpactedWirelessClientsExecute(r ApiGetSiteSleImpactedWirelessClientsRequest) (*SleImpactedUsers, *http.Response, error)

	/*
	GetSiteSleMetricClassifiers getSiteSleMetricClassifiers

	Get the list of classifiers for a specific metric

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleMetricClassifiersRequest
	*/
	GetSiteSleMetricClassifiers(ctx context.Context, siteId string, scope SiteSleMetricClassifiersScopeParameters, scopeId string, metric string) ApiGetSiteSleMetricClassifiersRequest

	// GetSiteSleMetricClassifiersExecute executes the request
	//  @return []string
	GetSiteSleMetricClassifiersExecute(r ApiGetSiteSleMetricClassifiersRequest) ([]string, *http.Response, error)

	/*
	GetSiteSleSummary getSiteSleSummary

	Get the summary for the SLE metric

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleSummaryRequest
	*/
	GetSiteSleSummary(ctx context.Context, siteId string, scope SiteSleMetricSummaryScopeParameters, scopeId string, metric string) ApiGetSiteSleSummaryRequest

	// GetSiteSleSummaryExecute executes the request
	//  @return SleSummary
	GetSiteSleSummaryExecute(r ApiGetSiteSleSummaryRequest) (*SleSummary, *http.Response, error)

	/*
	GetSiteSleThreshold getSiteSleThreshold

	Get the SLE threshold

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiGetSiteSleThresholdRequest
	*/
	GetSiteSleThreshold(ctx context.Context, siteId string, scope SiteSleThresholdScopeParameter, scopeId string, metric string) ApiGetSiteSleThresholdRequest

	// GetSiteSleThresholdExecute executes the request
	//  @return SleThreshold
	GetSiteSleThresholdExecute(r ApiGetSiteSleThresholdRequest) (*SleThreshold, *http.Response, error)

	/*
	GetSiteSlesMetrics getSiteSlesMetrics

	Get the list of metrics for the given scope

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@return ApiGetSiteSlesMetricsRequest
	*/
	GetSiteSlesMetrics(ctx context.Context, siteId string, scope SiteSleMetricsScopeParameters, scopeId string) ApiGetSiteSlesMetricsRequest

	// GetSiteSlesMetricsExecute executes the request
	//  @return SiteSleMetrics
	GetSiteSlesMetricsExecute(r ApiGetSiteSlesMetricsRequest) (*SiteSleMetrics, *http.Response, error)

	/*
	ReplaceSiteSleThreshold replaceSiteSleThreshold

	Replace the SLE threshold

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiReplaceSiteSleThresholdRequest
	*/
	ReplaceSiteSleThreshold(ctx context.Context, siteId string, scope SiteSleThresholdScopeParameter, scopeId string, metric string) ApiReplaceSiteSleThresholdRequest

	// ReplaceSiteSleThresholdExecute executes the request
	//  @return SleThreshold
	ReplaceSiteSleThresholdExecute(r ApiReplaceSiteSleThresholdRequest) (*SleThreshold, *http.Response, error)

	/*
	UpdateSiteSleThreshold updateSiteSleThreshold

	Update the SLE threshold

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param siteId
	@param scope
	@param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
	@param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
	@return ApiUpdateSiteSleThresholdRequest
	*/
	UpdateSiteSleThreshold(ctx context.Context, siteId string, scope SiteSleThresholdScopeParameter, scopeId string, metric string) ApiUpdateSiteSleThresholdRequest

	// UpdateSiteSleThresholdExecute executes the request
	//  @return SleThreshold
	UpdateSiteSleThresholdExecute(r ApiUpdateSiteSleThresholdRequest) (*SleThreshold, *http.Response, error)
}

// SitesSLEsAPIService SitesSLEsAPI service
type SitesSLEsAPIService service

type ApiGetSiteSleClassifierDetailsRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SleSummaryScope
	scopeId string
	metric string
	classifier string
	start *int32
	end *int32
	duration *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleClassifierDetailsRequest) Start(start int32) ApiGetSiteSleClassifierDetailsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleClassifierDetailsRequest) End(end int32) ApiGetSiteSleClassifierDetailsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleClassifierDetailsRequest) Duration(duration string) ApiGetSiteSleClassifierDetailsRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleClassifierDetailsRequest) Execute() (*SleClassifierSummary, *http.Response, error) {
	return r.ApiService.GetSiteSleClassifierDetailsExecute(r)
}

/*
GetSiteSleClassifierDetails getSiteSleClassifierDetails

Get SLE classifier details

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @param classifier
 @return ApiGetSiteSleClassifierDetailsRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleClassifierDetails(ctx context.Context, siteId string, scope SleSummaryScope, scopeId string, metric string, classifier string) ApiGetSiteSleClassifierDetailsRequest {
	return ApiGetSiteSleClassifierDetailsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
		classifier: classifier,
	}
}

// Execute executes the request
//  @return SleClassifierSummary
func (a *SitesSLEsAPIService) GetSiteSleClassifierDetailsExecute(r ApiGetSiteSleClassifierDetailsRequest) (*SleClassifierSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleClassifierSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleClassifierDetails")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/classifier/{classifier}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"classifier"+"}", url.PathEscape(parameterValueToString(r.classifier, "classifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleHistogramRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleHistogramScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleHistogramRequest) Start(start int32) ApiGetSiteSleHistogramRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleHistogramRequest) End(end int32) ApiGetSiteSleHistogramRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleHistogramRequest) Duration(duration string) ApiGetSiteSleHistogramRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleHistogramRequest) Execute() (*SleHistogram, *http.Response, error) {
	return r.ApiService.GetSiteSleHistogramExecute(r)
}

/*
GetSiteSleHistogram getSiteSleHistogram

Get the histogram for the SLE metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleHistogramRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleHistogram(ctx context.Context, siteId string, scope SiteSleHistogramScopeParameters, scopeId string, metric string) ApiGetSiteSleHistogramRequest {
	return ApiGetSiteSleHistogramRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleHistogram
func (a *SitesSLEsAPIService) GetSiteSleHistogramExecute(r ApiGetSiteSleHistogramRequest) (*SleHistogram, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleHistogram
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleHistogram")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/histogram"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactSummaryRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactSummaryScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	fields *SiteSleImpactSummaryFieldsParameter
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactSummaryRequest) Start(start int32) ApiGetSiteSleImpactSummaryRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactSummaryRequest) End(end int32) ApiGetSiteSleImpactSummaryRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactSummaryRequest) Duration(duration string) ApiGetSiteSleImpactSummaryRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactSummaryRequest) Fields(fields SiteSleImpactSummaryFieldsParameter) ApiGetSiteSleImpactSummaryRequest {
	r.fields = &fields
	return r
}

func (r ApiGetSiteSleImpactSummaryRequest) Classifier(classifier string) ApiGetSiteSleImpactSummaryRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactSummaryRequest) Execute() (*SleImpactSummary, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactSummaryExecute(r)
}

/*
GetSiteSleImpactSummary getSiteSleImpactSummary

Get impact summary counts optionally filtered by classifier and failure type
 
* Wireless SLE Fields: `wlan`, `device_type`, `device_os` ,`band`, `ap`, `server`, `mxedge`
* Wired SLE Fields: `switch`, `client`, `vlan`, `interface`, `chassis`
* WAN SLE Fields: `gateway`, `client`, `interface`, `chassis`, `peer_path`, `gateway_zones`

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactSummaryRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactSummary(ctx context.Context, siteId string, scope SiteSleImpactSummaryScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactSummaryRequest {
	return ApiGetSiteSleImpactSummaryRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactSummary
func (a *SitesSLEsAPIService) GetSiteSleImpactSummaryExecute(r ApiGetSiteSleImpactSummaryRequest) (*SleImpactSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impact-summary"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedApplicationsRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleScope
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedApplicationsRequest) Start(start int32) ApiGetSiteSleImpactedApplicationsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedApplicationsRequest) End(end int32) ApiGetSiteSleImpactedApplicationsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedApplicationsRequest) Duration(duration string) ApiGetSiteSleImpactedApplicationsRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedApplicationsRequest) Classifier(classifier string) ApiGetSiteSleImpactedApplicationsRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedApplicationsRequest) Execute() (*SleImpactedApplications, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedApplicationsExecute(r)
}

/*
GetSiteSleImpactedApplications getSiteSleImpactedApplications

For WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedApplicationsRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedApplications(ctx context.Context, siteId string, scope SiteSleScope, scopeId string, metric string) ApiGetSiteSleImpactedApplicationsRequest {
	return ApiGetSiteSleImpactedApplicationsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedApplications
func (a *SitesSLEsAPIService) GetSiteSleImpactedApplicationsExecute(r ApiGetSiteSleImpactedApplicationsRequest) (*SleImpactedApplications, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedApplications
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedApplications")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-applications"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedApsRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedApsScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedApsRequest) Start(start int32) ApiGetSiteSleImpactedApsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedApsRequest) End(end int32) ApiGetSiteSleImpactedApsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedApsRequest) Duration(duration string) ApiGetSiteSleImpactedApsRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedApsRequest) Classifier(classifier string) ApiGetSiteSleImpactedApsRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedApsRequest) Execute() (*SleImpactedAps, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedApsExecute(r)
}

/*
GetSiteSleImpactedAps getSiteSleImpactedAps

For Wireless SLEs. Get list of impacted APs optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedApsRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedAps(ctx context.Context, siteId string, scope SiteSleImpactedApsScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedApsRequest {
	return ApiGetSiteSleImpactedApsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedAps
func (a *SitesSLEsAPIService) GetSiteSleImpactedApsExecute(r ApiGetSiteSleImpactedApsRequest) (*SleImpactedAps, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedAps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedAps")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-aps"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedChassisRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedChassisScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedChassisRequest) Start(start int32) ApiGetSiteSleImpactedChassisRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedChassisRequest) End(end int32) ApiGetSiteSleImpactedChassisRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedChassisRequest) Duration(duration string) ApiGetSiteSleImpactedChassisRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedChassisRequest) Classifier(classifier string) ApiGetSiteSleImpactedChassisRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedChassisRequest) Execute() (*SleImpactedChassis, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedChassisExecute(r)
}

/*
GetSiteSleImpactedChassis getSiteSleImpactedChassis

For Wired and WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedChassisRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedChassis(ctx context.Context, siteId string, scope SiteSleImpactedChassisScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedChassisRequest {
	return ApiGetSiteSleImpactedChassisRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedChassis
func (a *SitesSLEsAPIService) GetSiteSleImpactedChassisExecute(r ApiGetSiteSleImpactedChassisRequest) (*SleImpactedChassis, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedChassis
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedChassis")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-chassis"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedGatewaysRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedGatewaysScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedGatewaysRequest) Start(start int32) ApiGetSiteSleImpactedGatewaysRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedGatewaysRequest) End(end int32) ApiGetSiteSleImpactedGatewaysRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedGatewaysRequest) Duration(duration string) ApiGetSiteSleImpactedGatewaysRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedGatewaysRequest) Classifier(classifier string) ApiGetSiteSleImpactedGatewaysRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedGatewaysRequest) Execute() (*SleImpactedGateways, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedGatewaysExecute(r)
}

/*
GetSiteSleImpactedGateways getSiteSleImpactedGateways

For WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedGatewaysRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedGateways(ctx context.Context, siteId string, scope SiteSleImpactedGatewaysScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedGatewaysRequest {
	return ApiGetSiteSleImpactedGatewaysRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedGateways
func (a *SitesSLEsAPIService) GetSiteSleImpactedGatewaysExecute(r ApiGetSiteSleImpactedGatewaysRequest) (*SleImpactedGateways, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedGateways
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedGateways")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-gateways"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedInterfacesRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedInterfacesScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedInterfacesRequest) Start(start int32) ApiGetSiteSleImpactedInterfacesRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedInterfacesRequest) End(end int32) ApiGetSiteSleImpactedInterfacesRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedInterfacesRequest) Duration(duration string) ApiGetSiteSleImpactedInterfacesRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedInterfacesRequest) Classifier(classifier string) ApiGetSiteSleImpactedInterfacesRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedInterfacesRequest) Execute() (*SleImpactedInterfaces, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedInterfacesExecute(r)
}

/*
GetSiteSleImpactedInterfaces getSiteSleImpactedInterfaces

For Wired and WAN SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedInterfacesRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedInterfaces(ctx context.Context, siteId string, scope SiteSleImpactedInterfacesScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedInterfacesRequest {
	return ApiGetSiteSleImpactedInterfacesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedInterfaces
func (a *SitesSLEsAPIService) GetSiteSleImpactedInterfacesExecute(r ApiGetSiteSleImpactedInterfacesRequest) (*SleImpactedInterfaces, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedInterfaces
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedInterfaces")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-interfaces"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedSwitchesRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedSwitchesScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedSwitchesRequest) Start(start int32) ApiGetSiteSleImpactedSwitchesRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedSwitchesRequest) End(end int32) ApiGetSiteSleImpactedSwitchesRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedSwitchesRequest) Duration(duration string) ApiGetSiteSleImpactedSwitchesRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedSwitchesRequest) Classifier(classifier string) ApiGetSiteSleImpactedSwitchesRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedSwitchesRequest) Execute() (*SleImpactedSwitches, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedSwitchesExecute(r)
}

/*
GetSiteSleImpactedSwitches getSiteSleImpactedSwitches

For Wired SLEs. Get list of impacted switches optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedSwitchesRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedSwitches(ctx context.Context, siteId string, scope SiteSleImpactedSwitchesScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedSwitchesRequest {
	return ApiGetSiteSleImpactedSwitchesRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedSwitches
func (a *SitesSLEsAPIService) GetSiteSleImpactedSwitchesExecute(r ApiGetSiteSleImpactedSwitchesRequest) (*SleImpactedSwitches, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedSwitches
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedSwitches")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-switches"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedWiredClientsRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedClientsScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedWiredClientsRequest) Start(start int32) ApiGetSiteSleImpactedWiredClientsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedWiredClientsRequest) End(end int32) ApiGetSiteSleImpactedWiredClientsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedWiredClientsRequest) Duration(duration string) ApiGetSiteSleImpactedWiredClientsRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedWiredClientsRequest) Classifier(classifier string) ApiGetSiteSleImpactedWiredClientsRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedWiredClientsRequest) Execute() (*SleImpactedClients, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedWiredClientsExecute(r)
}

/*
GetSiteSleImpactedWiredClients getSiteSleImpactedWiredClients

For Wired SLEs. Get list of impacted interfaces optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedWiredClientsRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedWiredClients(ctx context.Context, siteId string, scope SiteSleImpactedClientsScopeParameters, scopeId string, metric string) ApiGetSiteSleImpactedWiredClientsRequest {
	return ApiGetSiteSleImpactedWiredClientsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedClients
func (a *SitesSLEsAPIService) GetSiteSleImpactedWiredClientsExecute(r ApiGetSiteSleImpactedWiredClientsRequest) (*SleImpactedClients, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedClients
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedWiredClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted-clients"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleImpactedWirelessClientsRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleImpactedUsersScopeParameter
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
	classifier *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleImpactedWirelessClientsRequest) Start(start int32) ApiGetSiteSleImpactedWirelessClientsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleImpactedWirelessClientsRequest) End(end int32) ApiGetSiteSleImpactedWirelessClientsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleImpactedWirelessClientsRequest) Duration(duration string) ApiGetSiteSleImpactedWirelessClientsRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleImpactedWirelessClientsRequest) Classifier(classifier string) ApiGetSiteSleImpactedWirelessClientsRequest {
	r.classifier = &classifier
	return r
}

func (r ApiGetSiteSleImpactedWirelessClientsRequest) Execute() (*SleImpactedUsers, *http.Response, error) {
	return r.ApiService.GetSiteSleImpactedWirelessClientsExecute(r)
}

/*
GetSiteSleImpactedWirelessClients getSiteSleImpactedWirelessClients

For Wireless SLEs. Get list of impacted wireless users optionally filtered by classifier and failure type

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleImpactedWirelessClientsRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleImpactedWirelessClients(ctx context.Context, siteId string, scope SiteSleImpactedUsersScopeParameter, scopeId string, metric string) ApiGetSiteSleImpactedWirelessClientsRequest {
	return ApiGetSiteSleImpactedWirelessClientsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleImpactedUsers
func (a *SitesSLEsAPIService) GetSiteSleImpactedWirelessClientsExecute(r ApiGetSiteSleImpactedWirelessClientsRequest) (*SleImpactedUsers, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleImpactedUsers
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleImpactedWirelessClients")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/impacted_users"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	if r.classifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "classifier", r.classifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleMetricClassifiersRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleMetricClassifiersScopeParameters
	scopeId string
	metric string
}

func (r ApiGetSiteSleMetricClassifiersRequest) Execute() ([]string, *http.Response, error) {
	return r.ApiService.GetSiteSleMetricClassifiersExecute(r)
}

/*
GetSiteSleMetricClassifiers getSiteSleMetricClassifiers

Get the list of classifiers for a specific metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleMetricClassifiersRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleMetricClassifiers(ctx context.Context, siteId string, scope SiteSleMetricClassifiersScopeParameters, scopeId string, metric string) ApiGetSiteSleMetricClassifiersRequest {
	return ApiGetSiteSleMetricClassifiersRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return []string
func (a *SitesSLEsAPIService) GetSiteSleMetricClassifiersExecute(r ApiGetSiteSleMetricClassifiersRequest) ([]string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleMetricClassifiers")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/classifiers"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleSummaryRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleMetricSummaryScopeParameters
	scopeId string
	metric string
	start *int32
	end *int32
	duration *string
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiGetSiteSleSummaryRequest) Start(start int32) ApiGetSiteSleSummaryRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiGetSiteSleSummaryRequest) End(end int32) ApiGetSiteSleSummaryRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiGetSiteSleSummaryRequest) Duration(duration string) ApiGetSiteSleSummaryRequest {
	r.duration = &duration
	return r
}

func (r ApiGetSiteSleSummaryRequest) Execute() (*SleSummary, *http.Response, error) {
	return r.ApiService.GetSiteSleSummaryExecute(r)
}

/*
GetSiteSleSummary getSiteSleSummary

Get the summary for the SLE metric

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleSummaryRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleSummary(ctx context.Context, siteId string, scope SiteSleMetricSummaryScopeParameters, scopeId string, metric string) ApiGetSiteSleSummaryRequest {
	return ApiGetSiteSleSummaryRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleSummary
func (a *SitesSLEsAPIService) GetSiteSleSummaryExecute(r ApiGetSiteSleSummaryRequest) (*SleSummary, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleSummary")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSleThresholdRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleThresholdScopeParameter
	scopeId string
	metric string
}

func (r ApiGetSiteSleThresholdRequest) Execute() (*SleThreshold, *http.Response, error) {
	return r.ApiService.GetSiteSleThresholdExecute(r)
}

/*
GetSiteSleThreshold getSiteSleThreshold

Get the SLE threshold

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiGetSiteSleThresholdRequest
*/
func (a *SitesSLEsAPIService) GetSiteSleThreshold(ctx context.Context, siteId string, scope SiteSleThresholdScopeParameter, scopeId string, metric string) ApiGetSiteSleThresholdRequest {
	return ApiGetSiteSleThresholdRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleThreshold
func (a *SitesSLEsAPIService) GetSiteSleThresholdExecute(r ApiGetSiteSleThresholdRequest) (*SleThreshold, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleThreshold
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSleThreshold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/threshold"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetSiteSlesMetricsRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleMetricsScopeParameters
	scopeId string
}

func (r ApiGetSiteSlesMetricsRequest) Execute() (*SiteSleMetrics, *http.Response, error) {
	return r.ApiService.GetSiteSlesMetricsExecute(r)
}

/*
GetSiteSlesMetrics getSiteSlesMetrics

Get the list of metrics for the given scope

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @return ApiGetSiteSlesMetricsRequest
*/
func (a *SitesSLEsAPIService) GetSiteSlesMetrics(ctx context.Context, siteId string, scope SiteSleMetricsScopeParameters, scopeId string) ApiGetSiteSlesMetricsRequest {
	return ApiGetSiteSlesMetricsRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
	}
}

// Execute executes the request
//  @return SiteSleMetrics
func (a *SitesSLEsAPIService) GetSiteSlesMetricsExecute(r ApiGetSiteSlesMetricsRequest) (*SiteSleMetrics, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SiteSleMetrics
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.GetSiteSlesMetrics")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReplaceSiteSleThresholdRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleThresholdScopeParameter
	scopeId string
	metric string
	sleThreshold *SleThreshold
}

func (r ApiReplaceSiteSleThresholdRequest) SleThreshold(sleThreshold SleThreshold) ApiReplaceSiteSleThresholdRequest {
	r.sleThreshold = &sleThreshold
	return r
}

func (r ApiReplaceSiteSleThresholdRequest) Execute() (*SleThreshold, *http.Response, error) {
	return r.ApiService.ReplaceSiteSleThresholdExecute(r)
}

/*
ReplaceSiteSleThreshold replaceSiteSleThreshold

Replace the SLE threshold

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiReplaceSiteSleThresholdRequest
*/
func (a *SitesSLEsAPIService) ReplaceSiteSleThreshold(ctx context.Context, siteId string, scope SiteSleThresholdScopeParameter, scopeId string, metric string) ApiReplaceSiteSleThresholdRequest {
	return ApiReplaceSiteSleThresholdRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleThreshold
func (a *SitesSLEsAPIService) ReplaceSiteSleThresholdExecute(r ApiReplaceSiteSleThresholdRequest) (*SleThreshold, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleThreshold
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.ReplaceSiteSleThreshold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/threshold"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sleThreshold
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateSiteSleThresholdRequest struct {
	ctx context.Context
	ApiService SitesSLEsAPI
	siteId string
	scope SiteSleThresholdScopeParameter
	scopeId string
	metric string
	sleThreshold *SleThreshold
}

func (r ApiUpdateSiteSleThresholdRequest) SleThreshold(sleThreshold SleThreshold) ApiUpdateSiteSleThresholdRequest {
	r.sleThreshold = &sleThreshold
	return r
}

func (r ApiUpdateSiteSleThresholdRequest) Execute() (*SleThreshold, *http.Response, error) {
	return r.ApiService.UpdateSiteSleThresholdExecute(r)
}

/*
UpdateSiteSleThreshold updateSiteSleThreshold

Update the SLE threshold

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param siteId
 @param scope
 @param scopeId * site_id if `scope`==`site` * device_id if `scope`==`ap`, `scope`==`switch` or `scope`==`gateway` * mac if `scope`==`client`
 @param metric values from /api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metrics
 @return ApiUpdateSiteSleThresholdRequest
*/
func (a *SitesSLEsAPIService) UpdateSiteSleThreshold(ctx context.Context, siteId string, scope SiteSleThresholdScopeParameter, scopeId string, metric string) ApiUpdateSiteSleThresholdRequest {
	return ApiUpdateSiteSleThresholdRequest{
		ApiService: a,
		ctx: ctx,
		siteId: siteId,
		scope: scope,
		scopeId: scopeId,
		metric: metric,
	}
}

// Execute executes the request
//  @return SleThreshold
func (a *SitesSLEsAPIService) UpdateSiteSleThresholdExecute(r ApiUpdateSiteSleThresholdRequest) (*SleThreshold, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SleThreshold
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SitesSLEsAPIService.UpdateSiteSleThreshold")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/sites/{site_id}/sle/{scope}/{scope_id}/metric/{metric}/threshold"
	localVarPath = strings.Replace(localVarPath, "{"+"site_id"+"}", url.PathEscape(parameterValueToString(r.siteId, "siteId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope"+"}", url.PathEscape(parameterValueToString(r.scope, "scope")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"scope_id"+"}", url.PathEscape(parameterValueToString(r.scopeId, "scopeId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"metric"+"}", url.PathEscape(parameterValueToString(r.metric, "metric")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sleThreshold
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
