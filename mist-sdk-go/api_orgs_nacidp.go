/*
Mist API

> Version: **2406.1.14** > > Date: **July 3, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.14
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type OrgsNACIDPAPI interface {

	/*
	ValidateOrgIdpCredential validateOrgIdpCredential

	IDP Credential Validation. The output will be available through websocket. As there can be multiple command issued against the same device at the same time and the output all goes through the same websocket stream, `session` is introduced for demux.

#### Subscribe to Device Command outputs
`WS /api-ws/v1/stream`

``` json
{
    "subscribe": "orgs/:org_id/mist_nac/test_idp"
}

 ```

### Response (no idp can be found)

``` json
{
    "event": "data",
    "channel": "/orgs/:org_id/mist_nac/test_idp",
    "status": 
    "data": {
        "status": "failure",
        "error": "No matching IDP found"
    }
}

 ```

### Response OK

``` json
{
    "event": "data",
    "channel": "/orgs/:org_id/mist_nac/test_idp",
    "status": 
    "data": {
        "status": "success",
        "idp_id": "915793c0-1355-4e98-b1c0-23df2227b357",
        "idp_type": "ldap",
        // more attributes will be added later
    }
}

 ```

### Response Invalid Credentials

``` json
{
    "event": "data",
    "channel": "/orgs/:org_id/mist_nac/test_idp",
    "status": 
    "data": {
        "status": "failure",
        "error": "Invalid Credentials",
        "idp_id": "915793c0-1355-4e98-b1c0-23df2227b357",
        "idp_type": "ldap",
    }
}

 ```

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiValidateOrgIdpCredentialRequest
	*/
	ValidateOrgIdpCredential(ctx context.Context, orgId string) ApiValidateOrgIdpCredentialRequest

	// ValidateOrgIdpCredentialExecute executes the request
	//  @return WebsocketSession
	ValidateOrgIdpCredentialExecute(r ApiValidateOrgIdpCredentialRequest) (*WebsocketSession, *http.Response, error)
}

// OrgsNACIDPAPIService OrgsNACIDPAPI service
type OrgsNACIDPAPIService service

type ApiValidateOrgIdpCredentialRequest struct {
	ctx context.Context
	ApiService OrgsNACIDPAPI
	orgId string
	usernamePassword *UsernamePassword
}

func (r ApiValidateOrgIdpCredentialRequest) UsernamePassword(usernamePassword UsernamePassword) ApiValidateOrgIdpCredentialRequest {
	r.usernamePassword = &usernamePassword
	return r
}

func (r ApiValidateOrgIdpCredentialRequest) Execute() (*WebsocketSession, *http.Response, error) {
	return r.ApiService.ValidateOrgIdpCredentialExecute(r)
}

/*
ValidateOrgIdpCredential validateOrgIdpCredential

IDP Credential Validation. The output will be available through websocket. As there can be multiple command issued against the same device at the same time and the output all goes through the same websocket stream, `session` is introduced for demux.

#### Subscribe to Device Command outputs
`WS /api-ws/v1/stream`

``` json
{
    "subscribe": "orgs/:org_id/mist_nac/test_idp"
}

 ```

### Response (no idp can be found)

``` json
{
    "event": "data",
    "channel": "/orgs/:org_id/mist_nac/test_idp",
    "status": 
    "data": {
        "status": "failure",
        "error": "No matching IDP found"
    }
}

 ```

### Response OK

``` json
{
    "event": "data",
    "channel": "/orgs/:org_id/mist_nac/test_idp",
    "status": 
    "data": {
        "status": "success",
        "idp_id": "915793c0-1355-4e98-b1c0-23df2227b357",
        "idp_type": "ldap",
        // more attributes will be added later
    }
}

 ```

### Response Invalid Credentials

``` json
{
    "event": "data",
    "channel": "/orgs/:org_id/mist_nac/test_idp",
    "status": 
    "data": {
        "status": "failure",
        "error": "Invalid Credentials",
        "idp_id": "915793c0-1355-4e98-b1c0-23df2227b357",
        "idp_type": "ldap",
    }
}

 ```

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiValidateOrgIdpCredentialRequest
*/
func (a *OrgsNACIDPAPIService) ValidateOrgIdpCredential(ctx context.Context, orgId string) ApiValidateOrgIdpCredentialRequest {
	return ApiValidateOrgIdpCredentialRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return WebsocketSession
func (a *OrgsNACIDPAPIService) ValidateOrgIdpCredentialExecute(r ApiValidateOrgIdpCredentialRequest) (*WebsocketSession, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebsocketSession
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsNACIDPAPIService.ValidateOrgIdpCredential")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/mist_nac/test_idp"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.usernamePassword
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
