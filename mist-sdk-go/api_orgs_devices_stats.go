/*
Mist API

> Version: **2406.1.14** > > Date: **July 3, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.14
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type OrgsDevicesStatsAPI interface {

	/*
	CountOrgBgpStats countOrgBgpStats

	Count Org BGP Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiCountOrgBgpStatsRequest
	*/
	CountOrgBgpStats(ctx context.Context, orgId string) ApiCountOrgBgpStatsRequest

	// CountOrgBgpStatsExecute executes the request
	//  @return RepsonseCount
	CountOrgBgpStatsExecute(r ApiCountOrgBgpStatsRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountOrgSwitchPorts countOrgSwitchPorts

	Count by Distinct Attributes of Switch/Gateway Ports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiCountOrgSwitchPortsRequest
	*/
	CountOrgSwitchPorts(ctx context.Context, orgId string) ApiCountOrgSwitchPortsRequest

	// CountOrgSwitchPortsExecute executes the request
	//  @return RepsonseCount
	CountOrgSwitchPortsExecute(r ApiCountOrgSwitchPortsRequest) (*RepsonseCount, *http.Response, error)

	/*
	SearchOrgBgpStats searchOrgBgpStats

	Search Org BGP Stats

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiSearchOrgBgpStatsRequest
	*/
	SearchOrgBgpStats(ctx context.Context, orgId string) ApiSearchOrgBgpStatsRequest

	// SearchOrgBgpStatsExecute executes the request
	//  @return ResponseSearchBgps
	SearchOrgBgpStatsExecute(r ApiSearchOrgBgpStatsRequest) (*ResponseSearchBgps, *http.Response, error)

	/*
	SearchOrgSwOrGwPorts searchOrgSwOrGwPorts

	Search Switch / Gateway Ports

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiSearchOrgSwOrGwPortsRequest
	*/
	SearchOrgSwOrGwPorts(ctx context.Context, orgId string) ApiSearchOrgSwOrGwPortsRequest

	// SearchOrgSwOrGwPortsExecute executes the request
	//  @return ResponsePortStatsSearch
	SearchOrgSwOrGwPortsExecute(r ApiSearchOrgSwOrGwPortsRequest) (*ResponsePortStatsSearch, *http.Response, error)
}

// OrgsDevicesStatsAPIService OrgsDevicesStatsAPI service
type OrgsDevicesStatsAPIService service

type ApiCountOrgBgpStatsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesStatsAPI
	orgId string
}

func (r ApiCountOrgBgpStatsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountOrgBgpStatsExecute(r)
}

/*
CountOrgBgpStats countOrgBgpStats

Count Org BGP Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiCountOrgBgpStatsRequest
*/
func (a *OrgsDevicesStatsAPIService) CountOrgBgpStats(ctx context.Context, orgId string) ApiCountOrgBgpStatsRequest {
	return ApiCountOrgBgpStatsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *OrgsDevicesStatsAPIService) CountOrgBgpStatsExecute(r ApiCountOrgBgpStatsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesStatsAPIService.CountOrgBgpStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/stats/bgp_peers/count"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountOrgSwitchPortsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesStatsAPI
	orgId string
	distinct *OrgSwitchPortCountDistinct
	fullDuplex *bool
	mac *string
	neighborMac *string
	neighborPortDesc *string
	neighborSystemName *string
	poeDisabled *bool
	poeMode *string
	poeOn *bool
	portId *string
	portMac *string
	powerDraw *float32
	txPkts *int32
	rxPkts *int32
	rxBytes *int32
	txBps *int32
	rxBps *int32
	txMcastPkts *int32
	txBcastPkts *int32
	rxMcastPkts *int32
	rxBcastPkts *int32
	speed *int32
	stpState *CountOrgSwitchPortsStpState
	stpRole *CountOrgSwitchPortsStpRole
	authState *CountOrgSwitchPortsAuthState
	up *bool
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountOrgSwitchPortsRequest) Distinct(distinct OrgSwitchPortCountDistinct) ApiCountOrgSwitchPortsRequest {
	r.distinct = &distinct
	return r
}

// indicates full or half duplex
func (r ApiCountOrgSwitchPortsRequest) FullDuplex(fullDuplex bool) ApiCountOrgSwitchPortsRequest {
	r.fullDuplex = &fullDuplex
	return r
}

// device identifier
func (r ApiCountOrgSwitchPortsRequest) Mac(mac string) ApiCountOrgSwitchPortsRequest {
	r.mac = &mac
	return r
}

// Chassis identifier of the chassis type listed
func (r ApiCountOrgSwitchPortsRequest) NeighborMac(neighborMac string) ApiCountOrgSwitchPortsRequest {
	r.neighborMac = &neighborMac
	return r
}

// Description supplied by the system on the interface E.g. “GigabitEthernet2/0/39”
func (r ApiCountOrgSwitchPortsRequest) NeighborPortDesc(neighborPortDesc string) ApiCountOrgSwitchPortsRequest {
	r.neighborPortDesc = &neighborPortDesc
	return r
}

// Name supplied by the system on the interface E.g. neighbor system name E.g. “Kumar-Acc-SW.mist.local”
func (r ApiCountOrgSwitchPortsRequest) NeighborSystemName(neighborSystemName string) ApiCountOrgSwitchPortsRequest {
	r.neighborSystemName = &neighborSystemName
	return r
}

// is the POE configured not be disabled.
func (r ApiCountOrgSwitchPortsRequest) PoeDisabled(poeDisabled bool) ApiCountOrgSwitchPortsRequest {
	r.poeDisabled = &poeDisabled
	return r
}

// poe mode depending on class E.g. “802.3at”
func (r ApiCountOrgSwitchPortsRequest) PoeMode(poeMode string) ApiCountOrgSwitchPortsRequest {
	r.poeMode = &poeMode
	return r
}

// is the device attached to POE
func (r ApiCountOrgSwitchPortsRequest) PoeOn(poeOn bool) ApiCountOrgSwitchPortsRequest {
	r.poeOn = &poeOn
	return r
}

// interface name
func (r ApiCountOrgSwitchPortsRequest) PortId(portId string) ApiCountOrgSwitchPortsRequest {
	r.portId = &portId
	return r
}

// interface mac address
func (r ApiCountOrgSwitchPortsRequest) PortMac(portMac string) ApiCountOrgSwitchPortsRequest {
	r.portMac = &portMac
	return r
}

// Amount of power being used by the interface at the time the command is executed. Unit in watts.
func (r ApiCountOrgSwitchPortsRequest) PowerDraw(powerDraw float32) ApiCountOrgSwitchPortsRequest {
	r.powerDraw = &powerDraw
	return r
}

// Output packets
func (r ApiCountOrgSwitchPortsRequest) TxPkts(txPkts int32) ApiCountOrgSwitchPortsRequest {
	r.txPkts = &txPkts
	return r
}

// Input packets
func (r ApiCountOrgSwitchPortsRequest) RxPkts(rxPkts int32) ApiCountOrgSwitchPortsRequest {
	r.rxPkts = &rxPkts
	return r
}

// Input bytes
func (r ApiCountOrgSwitchPortsRequest) RxBytes(rxBytes int32) ApiCountOrgSwitchPortsRequest {
	r.rxBytes = &rxBytes
	return r
}

// Output rate
func (r ApiCountOrgSwitchPortsRequest) TxBps(txBps int32) ApiCountOrgSwitchPortsRequest {
	r.txBps = &txBps
	return r
}

// Input rate
func (r ApiCountOrgSwitchPortsRequest) RxBps(rxBps int32) ApiCountOrgSwitchPortsRequest {
	r.rxBps = &rxBps
	return r
}

// Multicast output packets
func (r ApiCountOrgSwitchPortsRequest) TxMcastPkts(txMcastPkts int32) ApiCountOrgSwitchPortsRequest {
	r.txMcastPkts = &txMcastPkts
	return r
}

// Broadcast output packets
func (r ApiCountOrgSwitchPortsRequest) TxBcastPkts(txBcastPkts int32) ApiCountOrgSwitchPortsRequest {
	r.txBcastPkts = &txBcastPkts
	return r
}

// Multicast input packets
func (r ApiCountOrgSwitchPortsRequest) RxMcastPkts(rxMcastPkts int32) ApiCountOrgSwitchPortsRequest {
	r.rxMcastPkts = &rxMcastPkts
	return r
}

// Broadcast input packets
func (r ApiCountOrgSwitchPortsRequest) RxBcastPkts(rxBcastPkts int32) ApiCountOrgSwitchPortsRequest {
	r.rxBcastPkts = &rxBcastPkts
	return r
}

// port speed
func (r ApiCountOrgSwitchPortsRequest) Speed(speed int32) ApiCountOrgSwitchPortsRequest {
	r.speed = &speed
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountOrgSwitchPortsRequest) StpState(stpState CountOrgSwitchPortsStpState) ApiCountOrgSwitchPortsRequest {
	r.stpState = &stpState
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountOrgSwitchPortsRequest) StpRole(stpRole CountOrgSwitchPortsStpRole) ApiCountOrgSwitchPortsRequest {
	r.stpRole = &stpRole
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiCountOrgSwitchPortsRequest) AuthState(authState CountOrgSwitchPortsAuthState) ApiCountOrgSwitchPortsRequest {
	r.authState = &authState
	return r
}

// indicates if interface is up
func (r ApiCountOrgSwitchPortsRequest) Up(up bool) ApiCountOrgSwitchPortsRequest {
	r.up = &up
	return r
}

func (r ApiCountOrgSwitchPortsRequest) Page(page int32) ApiCountOrgSwitchPortsRequest {
	r.page = &page
	return r
}

func (r ApiCountOrgSwitchPortsRequest) Limit(limit int32) ApiCountOrgSwitchPortsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountOrgSwitchPortsRequest) Start(start int32) ApiCountOrgSwitchPortsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountOrgSwitchPortsRequest) End(end int32) ApiCountOrgSwitchPortsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountOrgSwitchPortsRequest) Duration(duration string) ApiCountOrgSwitchPortsRequest {
	r.duration = &duration
	return r
}

func (r ApiCountOrgSwitchPortsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountOrgSwitchPortsExecute(r)
}

/*
CountOrgSwitchPorts countOrgSwitchPorts

Count by Distinct Attributes of Switch/Gateway Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiCountOrgSwitchPortsRequest
*/
func (a *OrgsDevicesStatsAPIService) CountOrgSwitchPorts(ctx context.Context, orgId string) ApiCountOrgSwitchPortsRequest {
	return ApiCountOrgSwitchPortsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *OrgsDevicesStatsAPIService) CountOrgSwitchPortsExecute(r ApiCountOrgSwitchPortsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesStatsAPIService.CountOrgSwitchPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/stats/switch_ports/count"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue OrgSwitchPortCountDistinct = "mac"
		r.distinct = &defaultValue
	}
	if r.fullDuplex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_duplex", r.fullDuplex, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.neighborMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_mac", r.neighborMac, "")
	}
	if r.neighborPortDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_port_desc", r.neighborPortDesc, "")
	}
	if r.neighborSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_system_name", r.neighborSystemName, "")
	}
	if r.poeDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_disabled", r.poeDisabled, "")
	}
	if r.poeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_mode", r.poeMode, "")
	}
	if r.poeOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_on", r.poeOn, "")
	}
	if r.portId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_id", r.portId, "")
	}
	if r.portMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_mac", r.portMac, "")
	}
	if r.powerDraw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_draw", r.powerDraw, "")
	}
	if r.txPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_pkts", r.txPkts, "")
	}
	if r.rxPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_pkts", r.rxPkts, "")
	}
	if r.rxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bytes", r.rxBytes, "")
	}
	if r.txBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bps", r.txBps, "")
	}
	if r.rxBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bps", r.rxBps, "")
	}
	if r.txMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_mcast_pkts", r.txMcastPkts, "")
	}
	if r.txBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bcast_pkts", r.txBcastPkts, "")
	}
	if r.rxMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_mcast_pkts", r.rxMcastPkts, "")
	}
	if r.rxBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bcast_pkts", r.rxBcastPkts, "")
	}
	if r.speed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speed", r.speed, "")
	}
	if r.stpState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_state", r.stpState, "")
	}
	if r.stpRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_role", r.stpRole, "")
	}
	if r.authState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_state", r.authState, "")
	}
	if r.up != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up", r.up, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOrgBgpStatsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesStatsAPI
	orgId string
}

func (r ApiSearchOrgBgpStatsRequest) Execute() (*ResponseSearchBgps, *http.Response, error) {
	return r.ApiService.SearchOrgBgpStatsExecute(r)
}

/*
SearchOrgBgpStats searchOrgBgpStats

Search Org BGP Stats

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiSearchOrgBgpStatsRequest
*/
func (a *OrgsDevicesStatsAPIService) SearchOrgBgpStats(ctx context.Context, orgId string) ApiSearchOrgBgpStatsRequest {
	return ApiSearchOrgBgpStatsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponseSearchBgps
func (a *OrgsDevicesStatsAPIService) SearchOrgBgpStatsExecute(r ApiSearchOrgBgpStatsRequest) (*ResponseSearchBgps, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseSearchBgps
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesStatsAPIService.SearchOrgBgpStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/stats/bgp_peers/search"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOrgSwOrGwPortsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesStatsAPI
	orgId string
	fullDuplex *bool
	mac *string
	neighborMac *string
	neighborPortDesc *string
	neighborSystemName *string
	poeDisabled *bool
	poeMode *string
	poeOn *bool
	portId *string
	portMac *string
	powerDraw *float32
	txPkts *int32
	rxPkts *int32
	rxBytes *int32
	txBps *int32
	rxBps *int32
	txErrors *int32
	rxErrors *int32
	txMcastPkts *int32
	txBcastPkts *int32
	rxMcastPkts *int32
	rxBcastPkts *int32
	speed *int32
	macLimit *int32
	macCount *int32
	up *bool
	stpState *SearchOrgSwOrGwPortsStpState
	stpRole *SearchOrgSwOrGwPortsStpRole
	authState *SearchOrgSwOrGwPortsAuthState
	limit *int32
	start *int32
	end *int32
	duration *string
}

// indicates full or half duplex
func (r ApiSearchOrgSwOrGwPortsRequest) FullDuplex(fullDuplex bool) ApiSearchOrgSwOrGwPortsRequest {
	r.fullDuplex = &fullDuplex
	return r
}

// device identifier
func (r ApiSearchOrgSwOrGwPortsRequest) Mac(mac string) ApiSearchOrgSwOrGwPortsRequest {
	r.mac = &mac
	return r
}

// Chassis identifier of the chassis type listed
func (r ApiSearchOrgSwOrGwPortsRequest) NeighborMac(neighborMac string) ApiSearchOrgSwOrGwPortsRequest {
	r.neighborMac = &neighborMac
	return r
}

// Description supplied by the system on the interface E.g. “GigabitEthernet2/0/39”
func (r ApiSearchOrgSwOrGwPortsRequest) NeighborPortDesc(neighborPortDesc string) ApiSearchOrgSwOrGwPortsRequest {
	r.neighborPortDesc = &neighborPortDesc
	return r
}

// Name supplied by the system on the interface E.g. neighbor system name E.g. “Kumar-Acc-SW.mist.local”
func (r ApiSearchOrgSwOrGwPortsRequest) NeighborSystemName(neighborSystemName string) ApiSearchOrgSwOrGwPortsRequest {
	r.neighborSystemName = &neighborSystemName
	return r
}

// is the POE configured not be disabled.
func (r ApiSearchOrgSwOrGwPortsRequest) PoeDisabled(poeDisabled bool) ApiSearchOrgSwOrGwPortsRequest {
	r.poeDisabled = &poeDisabled
	return r
}

// poe mode depending on class E.g. “802.3at”
func (r ApiSearchOrgSwOrGwPortsRequest) PoeMode(poeMode string) ApiSearchOrgSwOrGwPortsRequest {
	r.poeMode = &poeMode
	return r
}

// is the device attached to POE
func (r ApiSearchOrgSwOrGwPortsRequest) PoeOn(poeOn bool) ApiSearchOrgSwOrGwPortsRequest {
	r.poeOn = &poeOn
	return r
}

// interface name
func (r ApiSearchOrgSwOrGwPortsRequest) PortId(portId string) ApiSearchOrgSwOrGwPortsRequest {
	r.portId = &portId
	return r
}

// interface mac address
func (r ApiSearchOrgSwOrGwPortsRequest) PortMac(portMac string) ApiSearchOrgSwOrGwPortsRequest {
	r.portMac = &portMac
	return r
}

// Amount of power being used by the interface at the time the command is executed. Unit in watts.
func (r ApiSearchOrgSwOrGwPortsRequest) PowerDraw(powerDraw float32) ApiSearchOrgSwOrGwPortsRequest {
	r.powerDraw = &powerDraw
	return r
}

// Output packets
func (r ApiSearchOrgSwOrGwPortsRequest) TxPkts(txPkts int32) ApiSearchOrgSwOrGwPortsRequest {
	r.txPkts = &txPkts
	return r
}

// Input packets
func (r ApiSearchOrgSwOrGwPortsRequest) RxPkts(rxPkts int32) ApiSearchOrgSwOrGwPortsRequest {
	r.rxPkts = &rxPkts
	return r
}

// Input bytes
func (r ApiSearchOrgSwOrGwPortsRequest) RxBytes(rxBytes int32) ApiSearchOrgSwOrGwPortsRequest {
	r.rxBytes = &rxBytes
	return r
}

// Output rate
func (r ApiSearchOrgSwOrGwPortsRequest) TxBps(txBps int32) ApiSearchOrgSwOrGwPortsRequest {
	r.txBps = &txBps
	return r
}

// Input rate
func (r ApiSearchOrgSwOrGwPortsRequest) RxBps(rxBps int32) ApiSearchOrgSwOrGwPortsRequest {
	r.rxBps = &rxBps
	return r
}

// Output errors
func (r ApiSearchOrgSwOrGwPortsRequest) TxErrors(txErrors int32) ApiSearchOrgSwOrGwPortsRequest {
	r.txErrors = &txErrors
	return r
}

// Input errors
func (r ApiSearchOrgSwOrGwPortsRequest) RxErrors(rxErrors int32) ApiSearchOrgSwOrGwPortsRequest {
	r.rxErrors = &rxErrors
	return r
}

// Multicast output packets
func (r ApiSearchOrgSwOrGwPortsRequest) TxMcastPkts(txMcastPkts int32) ApiSearchOrgSwOrGwPortsRequest {
	r.txMcastPkts = &txMcastPkts
	return r
}

// Broadcast output packets
func (r ApiSearchOrgSwOrGwPortsRequest) TxBcastPkts(txBcastPkts int32) ApiSearchOrgSwOrGwPortsRequest {
	r.txBcastPkts = &txBcastPkts
	return r
}

// Multicast input packets
func (r ApiSearchOrgSwOrGwPortsRequest) RxMcastPkts(rxMcastPkts int32) ApiSearchOrgSwOrGwPortsRequest {
	r.rxMcastPkts = &rxMcastPkts
	return r
}

// Broadcast input packets
func (r ApiSearchOrgSwOrGwPortsRequest) RxBcastPkts(rxBcastPkts int32) ApiSearchOrgSwOrGwPortsRequest {
	r.rxBcastPkts = &rxBcastPkts
	return r
}

// port speed
func (r ApiSearchOrgSwOrGwPortsRequest) Speed(speed int32) ApiSearchOrgSwOrGwPortsRequest {
	r.speed = &speed
	return r
}

// Limit on number of dynamically learned macs
func (r ApiSearchOrgSwOrGwPortsRequest) MacLimit(macLimit int32) ApiSearchOrgSwOrGwPortsRequest {
	r.macLimit = &macLimit
	return r
}

// Number of mac addresses in the forwarding table
func (r ApiSearchOrgSwOrGwPortsRequest) MacCount(macCount int32) ApiSearchOrgSwOrGwPortsRequest {
	r.macCount = &macCount
	return r
}

// indicates if interface is up
func (r ApiSearchOrgSwOrGwPortsRequest) Up(up bool) ApiSearchOrgSwOrGwPortsRequest {
	r.up = &up
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiSearchOrgSwOrGwPortsRequest) StpState(stpState SearchOrgSwOrGwPortsStpState) ApiSearchOrgSwOrGwPortsRequest {
	r.stpState = &stpState
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60;
func (r ApiSearchOrgSwOrGwPortsRequest) StpRole(stpRole SearchOrgSwOrGwPortsStpRole) ApiSearchOrgSwOrGwPortsRequest {
	r.stpRole = &stpRole
	return r
}

// if &#x60;up&#x60;&#x3D;&#x3D;&#x60;true&#x60; &amp;&amp; has Authenticator role
func (r ApiSearchOrgSwOrGwPortsRequest) AuthState(authState SearchOrgSwOrGwPortsAuthState) ApiSearchOrgSwOrGwPortsRequest {
	r.authState = &authState
	return r
}

func (r ApiSearchOrgSwOrGwPortsRequest) Limit(limit int32) ApiSearchOrgSwOrGwPortsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchOrgSwOrGwPortsRequest) Start(start int32) ApiSearchOrgSwOrGwPortsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchOrgSwOrGwPortsRequest) End(end int32) ApiSearchOrgSwOrGwPortsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchOrgSwOrGwPortsRequest) Duration(duration string) ApiSearchOrgSwOrGwPortsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchOrgSwOrGwPortsRequest) Execute() (*ResponsePortStatsSearch, *http.Response, error) {
	return r.ApiService.SearchOrgSwOrGwPortsExecute(r)
}

/*
SearchOrgSwOrGwPorts searchOrgSwOrGwPorts

Search Switch / Gateway Ports

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiSearchOrgSwOrGwPortsRequest
*/
func (a *OrgsDevicesStatsAPIService) SearchOrgSwOrGwPorts(ctx context.Context, orgId string) ApiSearchOrgSwOrGwPortsRequest {
	return ApiSearchOrgSwOrGwPortsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponsePortStatsSearch
func (a *OrgsDevicesStatsAPIService) SearchOrgSwOrGwPortsExecute(r ApiSearchOrgSwOrGwPortsRequest) (*ResponsePortStatsSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponsePortStatsSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesStatsAPIService.SearchOrgSwOrGwPorts")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/stats/ports/search"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.fullDuplex != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "full_duplex", r.fullDuplex, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.neighborMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_mac", r.neighborMac, "")
	}
	if r.neighborPortDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_port_desc", r.neighborPortDesc, "")
	}
	if r.neighborSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "neighbor_system_name", r.neighborSystemName, "")
	}
	if r.poeDisabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_disabled", r.poeDisabled, "")
	}
	if r.poeMode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_mode", r.poeMode, "")
	}
	if r.poeOn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "poe_on", r.poeOn, "")
	}
	if r.portId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_id", r.portId, "")
	}
	if r.portMac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "port_mac", r.portMac, "")
	}
	if r.powerDraw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_draw", r.powerDraw, "")
	}
	if r.txPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_pkts", r.txPkts, "")
	}
	if r.rxPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_pkts", r.rxPkts, "")
	}
	if r.rxBytes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bytes", r.rxBytes, "")
	}
	if r.txBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bps", r.txBps, "")
	}
	if r.rxBps != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bps", r.rxBps, "")
	}
	if r.txErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_errors", r.txErrors, "")
	}
	if r.rxErrors != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_errors", r.rxErrors, "")
	}
	if r.txMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_mcast_pkts", r.txMcastPkts, "")
	}
	if r.txBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "tx_bcast_pkts", r.txBcastPkts, "")
	}
	if r.rxMcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_mcast_pkts", r.rxMcastPkts, "")
	}
	if r.rxBcastPkts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "rx_bcast_pkts", r.rxBcastPkts, "")
	}
	if r.speed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "speed", r.speed, "")
	}
	if r.macLimit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac_limit", r.macLimit, "")
	}
	if r.macCount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac_count", r.macCount, "")
	}
	if r.up != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "up", r.up, "")
	}
	if r.stpState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_state", r.stpState, "")
	}
	if r.stpRole != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "stp_role", r.stpRole, "")
	}
	if r.authState != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "auth_state", r.authState, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
