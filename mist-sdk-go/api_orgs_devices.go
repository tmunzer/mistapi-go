/*
Mist API

> Version: **2406.1.14** > > Date: **July 3, 2024**  ---  ### Additional Documentation * [Mist Automation Guide](https://www.juniper.net/documentation/us/en/software/mist/automation-integration/index.html) * [Mist Location SDK](https://www.juniper.net/documentation/us/en/software/mist/location_services/topics/concept/mist-how-get-mist-sdk.html) * [Mist Product Updates](https://www.mist.com/documentation/category/product-updates/)  ---  ### Helpful Resources * [API Sandbox and Exercises](https://api-class.mist.com/) * [Postman Collection, Runners and Webhook Samples](https://www.postman.com/juniper-mist/workspace/mist-systems-s-public-workspace) * [API Demo Apps](https://apps.mist-lab.fr/) * [Juniper Blog](https://blogs.juniper.net/)  --- 

API version: 2406.1.14
Contact: tmunzer@juniper.net
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mistsdkgo

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


type OrgsDevicesAPI interface {

	/*
	CountOrgDeviceEvents countOrgDeviceEvents

	Count Org Devices Events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiCountOrgDeviceEventsRequest
	*/
	CountOrgDeviceEvents(ctx context.Context, orgId string) ApiCountOrgDeviceEventsRequest

	// CountOrgDeviceEventsExecute executes the request
	//  @return RepsonseCount
	CountOrgDeviceEventsExecute(r ApiCountOrgDeviceEventsRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountOrgDeviceLastConfigs countOrgDeviceLastConfigs

	Counts the number of entries in device config history for distinct field with given filters

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiCountOrgDeviceLastConfigsRequest
	*/
	CountOrgDeviceLastConfigs(ctx context.Context, orgId string) ApiCountOrgDeviceLastConfigsRequest

	// CountOrgDeviceLastConfigsExecute executes the request
	//  @return RepsonseCount
	CountOrgDeviceLastConfigsExecute(r ApiCountOrgDeviceLastConfigsRequest) (*RepsonseCount, *http.Response, error)

	/*
	CountOrgDevices countOrgDevices

	Count Org Devices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiCountOrgDevicesRequest
	*/
	CountOrgDevices(ctx context.Context, orgId string) ApiCountOrgDevicesRequest

	// CountOrgDevicesExecute executes the request
	//  @return RepsonseCount
	CountOrgDevicesExecute(r ApiCountOrgDevicesRequest) (*RepsonseCount, *http.Response, error)

	/*
	GetOrgJuniperDevicesCommand getOrgJuniperDevicesCommand

	Get Org Juniper Devices command

Juniper devices can be managed/adopted by Mist. Currently outbound-ssh + netconf is used.
A few lines of CLI commands are generated per-Org, allowing the Juniper devices to phone home to Mist.

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiGetOrgJuniperDevicesCommandRequest
	*/
	GetOrgJuniperDevicesCommand(ctx context.Context, orgId string) ApiGetOrgJuniperDevicesCommandRequest

	// GetOrgJuniperDevicesCommandExecute executes the request
	//  @return ResponseDeviceConfigCmd
	GetOrgJuniperDevicesCommandExecute(r ApiGetOrgJuniperDevicesCommandRequest) (*ResponseDeviceConfigCmd, *http.Response, error)

	/*
	ListOrgApsMacs listOrgApsMacs

	For some scenarios like E911 or security systems, the BSSIDs are required to identify which AP the client is connecting to. Then the location of the AP can be used as the approximate location of the client.

Each radio MAC can have 16 BSSIDs (enumerate the last octet from 0-F)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiListOrgApsMacsRequest
	*/
	ListOrgApsMacs(ctx context.Context, orgId string) ApiListOrgApsMacsRequest

	// ListOrgApsMacsExecute executes the request
	//  @return []ApRadioMac
	ListOrgApsMacsExecute(r ApiListOrgApsMacsRequest) ([]ApRadioMac, *http.Response, error)

	/*
	ListOrgDevices listOrgDevices

	Get List of Org Devices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiListOrgDevicesRequest
	*/
	ListOrgDevices(ctx context.Context, orgId string) ApiListOrgDevicesRequest

	// ListOrgDevicesExecute executes the request
	//  @return ResponseOrgDevices
	ListOrgDevicesExecute(r ApiListOrgDevicesRequest) (*ResponseOrgDevices, *http.Response, error)

	/*
	ListOrgDevicesStats listOrgDevicesStats

	Get List of Org Devices stats
This API renders some high-level device stats, pagination is assumed and returned in response header (as the response is an array)

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiListOrgDevicesStatsRequest
	*/
	ListOrgDevicesStats(ctx context.Context, orgId string) ApiListOrgDevicesStatsRequest

	// ListOrgDevicesStatsExecute executes the request
	//  @return []StatsDevice
	ListOrgDevicesStatsExecute(r ApiListOrgDevicesStatsRequest) ([]StatsDevice, *http.Response, error)

	/*
	SearchOrgDeviceEvents searchOrgDeviceEvents

	Search Org Devices Events

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiSearchOrgDeviceEventsRequest
	*/
	SearchOrgDeviceEvents(ctx context.Context, orgId string) ApiSearchOrgDeviceEventsRequest

	// SearchOrgDeviceEventsExecute executes the request
	//  @return ResponseDeviceEventsSearch
	SearchOrgDeviceEventsExecute(r ApiSearchOrgDeviceEventsRequest) (*ResponseDeviceEventsSearch, *http.Response, error)

	/*
	SearchOrgDeviceLastConfigs searchOrgDeviceLastConfigs

	Search Device Last Configs

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiSearchOrgDeviceLastConfigsRequest
	*/
	SearchOrgDeviceLastConfigs(ctx context.Context, orgId string) ApiSearchOrgDeviceLastConfigsRequest

	// SearchOrgDeviceLastConfigsExecute executes the request
	//  @return ResponseConfigHistorySearch
	SearchOrgDeviceLastConfigsExecute(r ApiSearchOrgDeviceLastConfigsRequest) (*ResponseConfigHistorySearch, *http.Response, error)

	/*
	SearchOrgDevices searchOrgDevices

	Search Org Devices

	@param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
	@param orgId
	@return ApiSearchOrgDevicesRequest
	*/
	SearchOrgDevices(ctx context.Context, orgId string) ApiSearchOrgDevicesRequest

	// SearchOrgDevicesExecute executes the request
	//  @return ResponseDeviceSearch
	SearchOrgDevicesExecute(r ApiSearchOrgDevicesRequest) (*ResponseDeviceSearch, *http.Response, error)
}

// OrgsDevicesAPIService OrgsDevicesAPI service
type OrgsDevicesAPIService service

type ApiCountOrgDeviceEventsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	distinct *OrgDevicesEventsCountDistinct
	siteId *string
	ap *string
	apfw *string
	model *string
	text *string
	timestamp *string
	type_ *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountOrgDeviceEventsRequest) Distinct(distinct OrgDevicesEventsCountDistinct) ApiCountOrgDeviceEventsRequest {
	r.distinct = &distinct
	return r
}

// site id
func (r ApiCountOrgDeviceEventsRequest) SiteId(siteId string) ApiCountOrgDeviceEventsRequest {
	r.siteId = &siteId
	return r
}

// AP mac
func (r ApiCountOrgDeviceEventsRequest) Ap(ap string) ApiCountOrgDeviceEventsRequest {
	r.ap = &ap
	return r
}

// AP Firmware
func (r ApiCountOrgDeviceEventsRequest) Apfw(apfw string) ApiCountOrgDeviceEventsRequest {
	r.apfw = &apfw
	return r
}

// device model
func (r ApiCountOrgDeviceEventsRequest) Model(model string) ApiCountOrgDeviceEventsRequest {
	r.model = &model
	return r
}

// event message
func (r ApiCountOrgDeviceEventsRequest) Text(text string) ApiCountOrgDeviceEventsRequest {
	r.text = &text
	return r
}

// event time
func (r ApiCountOrgDeviceEventsRequest) Timestamp(timestamp string) ApiCountOrgDeviceEventsRequest {
	r.timestamp = &timestamp
	return r
}

// see [listDeviceEventsDefinitions]($e/Constants%20Events/listDeviceEventsDefinitions)
func (r ApiCountOrgDeviceEventsRequest) Type_(type_ string) ApiCountOrgDeviceEventsRequest {
	r.type_ = &type_
	return r
}

func (r ApiCountOrgDeviceEventsRequest) Limit(limit int32) ApiCountOrgDeviceEventsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountOrgDeviceEventsRequest) Start(start int32) ApiCountOrgDeviceEventsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountOrgDeviceEventsRequest) End(end int32) ApiCountOrgDeviceEventsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountOrgDeviceEventsRequest) Duration(duration string) ApiCountOrgDeviceEventsRequest {
	r.duration = &duration
	return r
}

func (r ApiCountOrgDeviceEventsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountOrgDeviceEventsExecute(r)
}

/*
CountOrgDeviceEvents countOrgDeviceEvents

Count Org Devices Events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiCountOrgDeviceEventsRequest
*/
func (a *OrgsDevicesAPIService) CountOrgDeviceEvents(ctx context.Context, orgId string) ApiCountOrgDeviceEventsRequest {
	return ApiCountOrgDeviceEventsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *OrgsDevicesAPIService) CountOrgDeviceEventsExecute(r ApiCountOrgDeviceEventsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.CountOrgDeviceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/events/count"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue OrgDevicesEventsCountDistinct = "model"
		r.distinct = &defaultValue
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	if r.ap != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ap", r.ap, "")
	}
	if r.apfw != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apfw", r.apfw, "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountOrgDeviceLastConfigsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	type_ *DeviceType
	distinct *OrgDevicesLastConfigsCountDistinct
	start *int32
	end *int32
	limit *int32
}

func (r ApiCountOrgDeviceLastConfigsRequest) Type_(type_ DeviceType) ApiCountOrgDeviceLastConfigsRequest {
	r.type_ = &type_
	return r
}

func (r ApiCountOrgDeviceLastConfigsRequest) Distinct(distinct OrgDevicesLastConfigsCountDistinct) ApiCountOrgDeviceLastConfigsRequest {
	r.distinct = &distinct
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountOrgDeviceLastConfigsRequest) Start(start int32) ApiCountOrgDeviceLastConfigsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountOrgDeviceLastConfigsRequest) End(end int32) ApiCountOrgDeviceLastConfigsRequest {
	r.end = &end
	return r
}

func (r ApiCountOrgDeviceLastConfigsRequest) Limit(limit int32) ApiCountOrgDeviceLastConfigsRequest {
	r.limit = &limit
	return r
}

func (r ApiCountOrgDeviceLastConfigsRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountOrgDeviceLastConfigsExecute(r)
}

/*
CountOrgDeviceLastConfigs countOrgDeviceLastConfigs

Counts the number of entries in device config history for distinct field with given filters

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiCountOrgDeviceLastConfigsRequest
*/
func (a *OrgsDevicesAPIService) CountOrgDeviceLastConfigs(ctx context.Context, orgId string) ApiCountOrgDeviceLastConfigsRequest {
	return ApiCountOrgDeviceLastConfigsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *OrgsDevicesAPIService) CountOrgDeviceLastConfigsExecute(r ApiCountOrgDeviceLastConfigsRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.CountOrgDeviceLastConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/last_config/count"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceType = "ap"
		r.type_ = &defaultValue
	}
	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCountOrgDevicesRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	distinct *OrgDevicesCountDistinct
	hostname *string
	siteId *string
	model *string
	mac *string
	version *string
	ipAddress *string
	mxtunnelStatus *CountOrgDevicesMxtunnelStatus
	mxedgeId *string
	lldpSystemName *string
	lldpSystemDesc *string
	lldpPortId *string
	lldpMgmtAddr *string
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiCountOrgDevicesRequest) Distinct(distinct OrgDevicesCountDistinct) ApiCountOrgDevicesRequest {
	r.distinct = &distinct
	return r
}

// partial / full hostname
func (r ApiCountOrgDevicesRequest) Hostname(hostname string) ApiCountOrgDevicesRequest {
	r.hostname = &hostname
	return r
}

// site id
func (r ApiCountOrgDevicesRequest) SiteId(siteId string) ApiCountOrgDevicesRequest {
	r.siteId = &siteId
	return r
}

// device model
func (r ApiCountOrgDevicesRequest) Model(model string) ApiCountOrgDevicesRequest {
	r.model = &model
	return r
}

// AP mac
func (r ApiCountOrgDevicesRequest) Mac(mac string) ApiCountOrgDevicesRequest {
	r.mac = &mac
	return r
}

// version
func (r ApiCountOrgDevicesRequest) Version(version string) ApiCountOrgDevicesRequest {
	r.version = &version
	return r
}

func (r ApiCountOrgDevicesRequest) IpAddress(ipAddress string) ApiCountOrgDevicesRequest {
	r.ipAddress = &ipAddress
	return r
}

// MxTunnel status, up / down
func (r ApiCountOrgDevicesRequest) MxtunnelStatus(mxtunnelStatus CountOrgDevicesMxtunnelStatus) ApiCountOrgDevicesRequest {
	r.mxtunnelStatus = &mxtunnelStatus
	return r
}

// Mist Edge id, if AP is connecting to a Mist Edge
func (r ApiCountOrgDevicesRequest) MxedgeId(mxedgeId string) ApiCountOrgDevicesRequest {
	r.mxedgeId = &mxedgeId
	return r
}

// LLDP system name
func (r ApiCountOrgDevicesRequest) LldpSystemName(lldpSystemName string) ApiCountOrgDevicesRequest {
	r.lldpSystemName = &lldpSystemName
	return r
}

// LLDP system description
func (r ApiCountOrgDevicesRequest) LldpSystemDesc(lldpSystemDesc string) ApiCountOrgDevicesRequest {
	r.lldpSystemDesc = &lldpSystemDesc
	return r
}

// LLDP port id
func (r ApiCountOrgDevicesRequest) LldpPortId(lldpPortId string) ApiCountOrgDevicesRequest {
	r.lldpPortId = &lldpPortId
	return r
}

// LLDP management ip address
func (r ApiCountOrgDevicesRequest) LldpMgmtAddr(lldpMgmtAddr string) ApiCountOrgDevicesRequest {
	r.lldpMgmtAddr = &lldpMgmtAddr
	return r
}

func (r ApiCountOrgDevicesRequest) Page(page int32) ApiCountOrgDevicesRequest {
	r.page = &page
	return r
}

func (r ApiCountOrgDevicesRequest) Limit(limit int32) ApiCountOrgDevicesRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiCountOrgDevicesRequest) Start(start int32) ApiCountOrgDevicesRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiCountOrgDevicesRequest) End(end int32) ApiCountOrgDevicesRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiCountOrgDevicesRequest) Duration(duration string) ApiCountOrgDevicesRequest {
	r.duration = &duration
	return r
}

func (r ApiCountOrgDevicesRequest) Execute() (*RepsonseCount, *http.Response, error) {
	return r.ApiService.CountOrgDevicesExecute(r)
}

/*
CountOrgDevices countOrgDevices

Count Org Devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiCountOrgDevicesRequest
*/
func (a *OrgsDevicesAPIService) CountOrgDevices(ctx context.Context, orgId string) ApiCountOrgDevicesRequest {
	return ApiCountOrgDevicesRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return RepsonseCount
func (a *OrgsDevicesAPIService) CountOrgDevicesExecute(r ApiCountOrgDevicesRequest) (*RepsonseCount, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *RepsonseCount
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.CountOrgDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/count"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinct != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct", r.distinct, "")
	} else {
		var defaultValue OrgDevicesCountDistinct = "model"
		r.distinct = &defaultValue
	}
	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", r.ipAddress, "")
	}
	if r.mxtunnelStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxtunnel_status", r.mxtunnelStatus, "")
	}
	if r.mxedgeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxedge_id", r.mxedgeId, "")
	}
	if r.lldpSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_name", r.lldpSystemName, "")
	}
	if r.lldpSystemDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_desc", r.lldpSystemDesc, "")
	}
	if r.lldpPortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_port_id", r.lldpPortId, "")
	}
	if r.lldpMgmtAddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_mgmt_addr", r.lldpMgmtAddr, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrgJuniperDevicesCommandRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	siteId *string
}

// site_id would be used for proxy config check of the site and automatic site assignment
func (r ApiGetOrgJuniperDevicesCommandRequest) SiteId(siteId string) ApiGetOrgJuniperDevicesCommandRequest {
	r.siteId = &siteId
	return r
}

func (r ApiGetOrgJuniperDevicesCommandRequest) Execute() (*ResponseDeviceConfigCmd, *http.Response, error) {
	return r.ApiService.GetOrgJuniperDevicesCommandExecute(r)
}

/*
GetOrgJuniperDevicesCommand getOrgJuniperDevicesCommand

Get Org Juniper Devices command

Juniper devices can be managed/adopted by Mist. Currently outbound-ssh + netconf is used.
A few lines of CLI commands are generated per-Org, allowing the Juniper devices to phone home to Mist.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiGetOrgJuniperDevicesCommandRequest
*/
func (a *OrgsDevicesAPIService) GetOrgJuniperDevicesCommand(ctx context.Context, orgId string) ApiGetOrgJuniperDevicesCommandRequest {
	return ApiGetOrgJuniperDevicesCommandRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponseDeviceConfigCmd
func (a *OrgsDevicesAPIService) GetOrgJuniperDevicesCommandExecute(r ApiGetOrgJuniperDevicesCommandRequest) (*ResponseDeviceConfigCmd, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseDeviceConfigCmd
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.GetOrgJuniperDevicesCommand")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/ocdevices/outbound_ssh_cmd"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrgApsMacsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	page *int32
	limit *int32
}

func (r ApiListOrgApsMacsRequest) Page(page int32) ApiListOrgApsMacsRequest {
	r.page = &page
	return r
}

func (r ApiListOrgApsMacsRequest) Limit(limit int32) ApiListOrgApsMacsRequest {
	r.limit = &limit
	return r
}

func (r ApiListOrgApsMacsRequest) Execute() ([]ApRadioMac, *http.Response, error) {
	return r.ApiService.ListOrgApsMacsExecute(r)
}

/*
ListOrgApsMacs listOrgApsMacs

For some scenarios like E911 or security systems, the BSSIDs are required to identify which AP the client is connecting to. Then the location of the AP can be used as the approximate location of the client.

Each radio MAC can have 16 BSSIDs (enumerate the last octet from 0-F)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiListOrgApsMacsRequest
*/
func (a *OrgsDevicesAPIService) ListOrgApsMacs(ctx context.Context, orgId string) ApiListOrgApsMacsRequest {
	return ApiListOrgApsMacsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return []ApRadioMac
func (a *OrgsDevicesAPIService) ListOrgApsMacsExecute(r ApiListOrgApsMacsRequest) ([]ApRadioMac, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []ApRadioMac
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.ListOrgApsMacs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/radio_macs"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrgDevicesRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
}

func (r ApiListOrgDevicesRequest) Execute() (*ResponseOrgDevices, *http.Response, error) {
	return r.ApiService.ListOrgDevicesExecute(r)
}

/*
ListOrgDevices listOrgDevices

Get List of Org Devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiListOrgDevicesRequest
*/
func (a *OrgsDevicesAPIService) ListOrgDevices(ctx context.Context, orgId string) ApiListOrgDevicesRequest {
	return ApiListOrgDevicesRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponseOrgDevices
func (a *OrgsDevicesAPIService) ListOrgDevicesExecute(r ApiListOrgDevicesRequest) (*ResponseOrgDevices, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseOrgDevices
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.ListOrgDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListOrgDevicesStatsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	type_ *DeviceTypeWithAll
	status *DeviceStatus
	siteId *string
	mac *string
	evpntopoId *string
	evpnUnused *string
	fields *string
	page *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

func (r ApiListOrgDevicesStatsRequest) Type_(type_ DeviceTypeWithAll) ApiListOrgDevicesStatsRequest {
	r.type_ = &type_
	return r
}

func (r ApiListOrgDevicesStatsRequest) Status(status DeviceStatus) ApiListOrgDevicesStatsRequest {
	r.status = &status
	return r
}

func (r ApiListOrgDevicesStatsRequest) SiteId(siteId string) ApiListOrgDevicesStatsRequest {
	r.siteId = &siteId
	return r
}

func (r ApiListOrgDevicesStatsRequest) Mac(mac string) ApiListOrgDevicesStatsRequest {
	r.mac = &mac
	return r
}

// EVPN Topology ID
func (r ApiListOrgDevicesStatsRequest) EvpntopoId(evpntopoId string) ApiListOrgDevicesStatsRequest {
	r.evpntopoId = &evpntopoId
	return r
}

// if &#x60;evpn_unused&#x60;&#x3D;&#x3D;&#x60;true&#x60;, find EVPN eligible switches which don’t belong to any EVPN Topology yet
func (r ApiListOrgDevicesStatsRequest) EvpnUnused(evpnUnused string) ApiListOrgDevicesStatsRequest {
	r.evpnUnused = &evpnUnused
	return r
}

// list of additional fields requests, comma separeted, or &#x60;fields&#x3D;*&#x60; for all of them
func (r ApiListOrgDevicesStatsRequest) Fields(fields string) ApiListOrgDevicesStatsRequest {
	r.fields = &fields
	return r
}

func (r ApiListOrgDevicesStatsRequest) Page(page int32) ApiListOrgDevicesStatsRequest {
	r.page = &page
	return r
}

func (r ApiListOrgDevicesStatsRequest) Limit(limit int32) ApiListOrgDevicesStatsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiListOrgDevicesStatsRequest) Start(start int32) ApiListOrgDevicesStatsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiListOrgDevicesStatsRequest) End(end int32) ApiListOrgDevicesStatsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiListOrgDevicesStatsRequest) Duration(duration string) ApiListOrgDevicesStatsRequest {
	r.duration = &duration
	return r
}

func (r ApiListOrgDevicesStatsRequest) Execute() ([]StatsDevice, *http.Response, error) {
	return r.ApiService.ListOrgDevicesStatsExecute(r)
}

/*
ListOrgDevicesStats listOrgDevicesStats

Get List of Org Devices stats
This API renders some high-level device stats, pagination is assumed and returned in response header (as the response is an array)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiListOrgDevicesStatsRequest
*/
func (a *OrgsDevicesAPIService) ListOrgDevicesStats(ctx context.Context, orgId string) ApiListOrgDevicesStatsRequest {
	return ApiListOrgDevicesStatsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return []StatsDevice
func (a *OrgsDevicesAPIService) ListOrgDevicesStatsExecute(r ApiListOrgDevicesStatsRequest) ([]StatsDevice, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []StatsDevice
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.ListOrgDevicesStats")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/stats/devices"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceTypeWithAll = "ap"
		r.type_ = &defaultValue
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	} else {
		var defaultValue DeviceStatus = "all"
		r.status = &defaultValue
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.evpntopoId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evpntopo_id", r.evpntopoId, "")
	}
	if r.evpnUnused != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "evpn_unused", r.evpnUnused, "")
	}
	if r.fields != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "fields", r.fields, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 1
		r.page = &defaultValue
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOrgDeviceEventsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	mac *string
	model *string
	deviceType *DeviceType
	text *string
	timestamp *string
	type_ *string
	lastBy *string
	limit *int32
	start *int32
	end *int32
	duration *string
}

// device mac
func (r ApiSearchOrgDeviceEventsRequest) Mac(mac string) ApiSearchOrgDeviceEventsRequest {
	r.mac = &mac
	return r
}

// device model
func (r ApiSearchOrgDeviceEventsRequest) Model(model string) ApiSearchOrgDeviceEventsRequest {
	r.model = &model
	return r
}

func (r ApiSearchOrgDeviceEventsRequest) DeviceType(deviceType DeviceType) ApiSearchOrgDeviceEventsRequest {
	r.deviceType = &deviceType
	return r
}

// event message
func (r ApiSearchOrgDeviceEventsRequest) Text(text string) ApiSearchOrgDeviceEventsRequest {
	r.text = &text
	return r
}

// event time
func (r ApiSearchOrgDeviceEventsRequest) Timestamp(timestamp string) ApiSearchOrgDeviceEventsRequest {
	r.timestamp = &timestamp
	return r
}

// see [listDeviceEventsDefinitions]($e/Constants%20Events/listDeviceEventsDefinitions)
func (r ApiSearchOrgDeviceEventsRequest) Type_(type_ string) ApiSearchOrgDeviceEventsRequest {
	r.type_ = &type_
	return r
}

// Return last/recent event for passed in field
func (r ApiSearchOrgDeviceEventsRequest) LastBy(lastBy string) ApiSearchOrgDeviceEventsRequest {
	r.lastBy = &lastBy
	return r
}

func (r ApiSearchOrgDeviceEventsRequest) Limit(limit int32) ApiSearchOrgDeviceEventsRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchOrgDeviceEventsRequest) Start(start int32) ApiSearchOrgDeviceEventsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchOrgDeviceEventsRequest) End(end int32) ApiSearchOrgDeviceEventsRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchOrgDeviceEventsRequest) Duration(duration string) ApiSearchOrgDeviceEventsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchOrgDeviceEventsRequest) Execute() (*ResponseDeviceEventsSearch, *http.Response, error) {
	return r.ApiService.SearchOrgDeviceEventsExecute(r)
}

/*
SearchOrgDeviceEvents searchOrgDeviceEvents

Search Org Devices Events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiSearchOrgDeviceEventsRequest
*/
func (a *OrgsDevicesAPIService) SearchOrgDeviceEvents(ctx context.Context, orgId string) ApiSearchOrgDeviceEventsRequest {
	return ApiSearchOrgDeviceEventsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponseDeviceEventsSearch
func (a *OrgsDevicesAPIService) SearchOrgDeviceEventsExecute(r ApiSearchOrgDeviceEventsRequest) (*ResponseDeviceEventsSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseDeviceEventsSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.SearchOrgDeviceEvents")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/events/search"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.deviceType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "device_type", r.deviceType, "")
	} else {
		var defaultValue DeviceType = "ap"
		r.deviceType = &defaultValue
	}
	if r.text != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "text", r.text, "")
	}
	if r.timestamp != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "timestamp", r.timestamp, "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	}
	if r.lastBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "last_by", r.lastBy, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOrgDeviceLastConfigsRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	type_ *DeviceType
	mac *string
	name *string
	version *string
	start *int32
	end *int32
	limit *int32
	duration *string
}

func (r ApiSearchOrgDeviceLastConfigsRequest) Type_(type_ DeviceType) ApiSearchOrgDeviceLastConfigsRequest {
	r.type_ = &type_
	return r
}

// Device MAC address
func (r ApiSearchOrgDeviceLastConfigsRequest) Mac(mac string) ApiSearchOrgDeviceLastConfigsRequest {
	r.mac = &mac
	return r
}

// Devices Name
func (r ApiSearchOrgDeviceLastConfigsRequest) Name(name string) ApiSearchOrgDeviceLastConfigsRequest {
	r.name = &name
	return r
}

// Device Version
func (r ApiSearchOrgDeviceLastConfigsRequest) Version(version string) ApiSearchOrgDeviceLastConfigsRequest {
	r.version = &version
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchOrgDeviceLastConfigsRequest) Start(start int32) ApiSearchOrgDeviceLastConfigsRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchOrgDeviceLastConfigsRequest) End(end int32) ApiSearchOrgDeviceLastConfigsRequest {
	r.end = &end
	return r
}

func (r ApiSearchOrgDeviceLastConfigsRequest) Limit(limit int32) ApiSearchOrgDeviceLastConfigsRequest {
	r.limit = &limit
	return r
}

// duration like 7d, 2w
func (r ApiSearchOrgDeviceLastConfigsRequest) Duration(duration string) ApiSearchOrgDeviceLastConfigsRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchOrgDeviceLastConfigsRequest) Execute() (*ResponseConfigHistorySearch, *http.Response, error) {
	return r.ApiService.SearchOrgDeviceLastConfigsExecute(r)
}

/*
SearchOrgDeviceLastConfigs searchOrgDeviceLastConfigs

Search Device Last Configs

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiSearchOrgDeviceLastConfigsRequest
*/
func (a *OrgsDevicesAPIService) SearchOrgDeviceLastConfigs(ctx context.Context, orgId string) ApiSearchOrgDeviceLastConfigsRequest {
	return ApiSearchOrgDeviceLastConfigsRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponseConfigHistorySearch
func (a *OrgsDevicesAPIService) SearchOrgDeviceLastConfigsExecute(r ApiSearchOrgDeviceLastConfigsRequest) (*ResponseConfigHistorySearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseConfigHistorySearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.SearchOrgDeviceLastConfigs")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/last_config/search"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	} else {
		var defaultValue DeviceType = "ap"
		r.type_ = &defaultValue
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.name != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchOrgDevicesRequest struct {
	ctx context.Context
	ApiService OrgsDevicesAPI
	orgId string
	hostname *string
	siteId *string
	model *string
	mac *string
	version *string
	powerConstrained *bool
	ipAddress *string
	mxtunnelStatus *SearchOrgDevicesMxtunnelStatus
	mxedgeId *string
	lldpSystemName *string
	lldpSystemDesc *string
	lldpPortId *string
	lldpMgmtAddr *string
	band24Bandwith *int32
	band5Bandwith *int32
	band6Bandwith *int32
	band24Channel *int32
	band5Channel *int32
	band6Channel *int32
	eth0PortSpeed *int32
	limit *int32
	start *int32
	end *int32
	duration *string
}

// partial / full hostname
func (r ApiSearchOrgDevicesRequest) Hostname(hostname string) ApiSearchOrgDevicesRequest {
	r.hostname = &hostname
	return r
}

// site id
func (r ApiSearchOrgDevicesRequest) SiteId(siteId string) ApiSearchOrgDevicesRequest {
	r.siteId = &siteId
	return r
}

// device model
func (r ApiSearchOrgDevicesRequest) Model(model string) ApiSearchOrgDevicesRequest {
	r.model = &model
	return r
}

// AP mac
func (r ApiSearchOrgDevicesRequest) Mac(mac string) ApiSearchOrgDevicesRequest {
	r.mac = &mac
	return r
}

// version
func (r ApiSearchOrgDevicesRequest) Version(version string) ApiSearchOrgDevicesRequest {
	r.version = &version
	return r
}

// power_constrained
func (r ApiSearchOrgDevicesRequest) PowerConstrained(powerConstrained bool) ApiSearchOrgDevicesRequest {
	r.powerConstrained = &powerConstrained
	return r
}

func (r ApiSearchOrgDevicesRequest) IpAddress(ipAddress string) ApiSearchOrgDevicesRequest {
	r.ipAddress = &ipAddress
	return r
}

// MxTunnel status, up / down
func (r ApiSearchOrgDevicesRequest) MxtunnelStatus(mxtunnelStatus SearchOrgDevicesMxtunnelStatus) ApiSearchOrgDevicesRequest {
	r.mxtunnelStatus = &mxtunnelStatus
	return r
}

// Mist Edge id, if AP is connecting to a Mist Edge
func (r ApiSearchOrgDevicesRequest) MxedgeId(mxedgeId string) ApiSearchOrgDevicesRequest {
	r.mxedgeId = &mxedgeId
	return r
}

// LLDP system name
func (r ApiSearchOrgDevicesRequest) LldpSystemName(lldpSystemName string) ApiSearchOrgDevicesRequest {
	r.lldpSystemName = &lldpSystemName
	return r
}

// LLDP system description
func (r ApiSearchOrgDevicesRequest) LldpSystemDesc(lldpSystemDesc string) ApiSearchOrgDevicesRequest {
	r.lldpSystemDesc = &lldpSystemDesc
	return r
}

// LLDP port id
func (r ApiSearchOrgDevicesRequest) LldpPortId(lldpPortId string) ApiSearchOrgDevicesRequest {
	r.lldpPortId = &lldpPortId
	return r
}

// LLDP management ip address
func (r ApiSearchOrgDevicesRequest) LldpMgmtAddr(lldpMgmtAddr string) ApiSearchOrgDevicesRequest {
	r.lldpMgmtAddr = &lldpMgmtAddr
	return r
}

// Bandwith of band_24
func (r ApiSearchOrgDevicesRequest) Band24Bandwith(band24Bandwith int32) ApiSearchOrgDevicesRequest {
	r.band24Bandwith = &band24Bandwith
	return r
}

// Bandwith of band_5
func (r ApiSearchOrgDevicesRequest) Band5Bandwith(band5Bandwith int32) ApiSearchOrgDevicesRequest {
	r.band5Bandwith = &band5Bandwith
	return r
}

// Bandwith of band_6
func (r ApiSearchOrgDevicesRequest) Band6Bandwith(band6Bandwith int32) ApiSearchOrgDevicesRequest {
	r.band6Bandwith = &band6Bandwith
	return r
}

// Channel of band_24
func (r ApiSearchOrgDevicesRequest) Band24Channel(band24Channel int32) ApiSearchOrgDevicesRequest {
	r.band24Channel = &band24Channel
	return r
}

// Channel of band_5
func (r ApiSearchOrgDevicesRequest) Band5Channel(band5Channel int32) ApiSearchOrgDevicesRequest {
	r.band5Channel = &band5Channel
	return r
}

// Channel of band_6
func (r ApiSearchOrgDevicesRequest) Band6Channel(band6Channel int32) ApiSearchOrgDevicesRequest {
	r.band6Channel = &band6Channel
	return r
}

// Port speed of eth0
func (r ApiSearchOrgDevicesRequest) Eth0PortSpeed(eth0PortSpeed int32) ApiSearchOrgDevicesRequest {
	r.eth0PortSpeed = &eth0PortSpeed
	return r
}

func (r ApiSearchOrgDevicesRequest) Limit(limit int32) ApiSearchOrgDevicesRequest {
	r.limit = &limit
	return r
}

// start datetime, can be epoch or relative time like -1d, -1w; -1d if not specified
func (r ApiSearchOrgDevicesRequest) Start(start int32) ApiSearchOrgDevicesRequest {
	r.start = &start
	return r
}

// end datetime, can be epoch or relative time like -1d, -2h; now if not specified
func (r ApiSearchOrgDevicesRequest) End(end int32) ApiSearchOrgDevicesRequest {
	r.end = &end
	return r
}

// duration like 7d, 2w
func (r ApiSearchOrgDevicesRequest) Duration(duration string) ApiSearchOrgDevicesRequest {
	r.duration = &duration
	return r
}

func (r ApiSearchOrgDevicesRequest) Execute() (*ResponseDeviceSearch, *http.Response, error) {
	return r.ApiService.SearchOrgDevicesExecute(r)
}

/*
SearchOrgDevices searchOrgDevices

Search Org Devices

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orgId
 @return ApiSearchOrgDevicesRequest
*/
func (a *OrgsDevicesAPIService) SearchOrgDevices(ctx context.Context, orgId string) ApiSearchOrgDevicesRequest {
	return ApiSearchOrgDevicesRequest{
		ApiService: a,
		ctx: ctx,
		orgId: orgId,
	}
}

// Execute executes the request
//  @return ResponseDeviceSearch
func (a *OrgsDevicesAPIService) SearchOrgDevicesExecute(r ApiSearchOrgDevicesRequest) (*ResponseDeviceSearch, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ResponseDeviceSearch
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "OrgsDevicesAPIService.SearchOrgDevices")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v1/orgs/{org_id}/devices/search"
	localVarPath = strings.Replace(localVarPath, "{"+"org_id"+"}", url.PathEscape(parameterValueToString(r.orgId, "orgId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.hostname != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hostname", r.hostname, "")
	}
	if r.siteId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "site_id", r.siteId, "")
	}
	if r.model != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "model", r.model, "")
	}
	if r.mac != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mac", r.mac, "")
	}
	if r.version != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "version", r.version, "")
	}
	if r.powerConstrained != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "power_constrained", r.powerConstrained, "")
	}
	if r.ipAddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ip_address", r.ipAddress, "")
	}
	if r.mxtunnelStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxtunnel_status", r.mxtunnelStatus, "")
	}
	if r.mxedgeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "mxedge_id", r.mxedgeId, "")
	}
	if r.lldpSystemName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_name", r.lldpSystemName, "")
	}
	if r.lldpSystemDesc != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_system_desc", r.lldpSystemDesc, "")
	}
	if r.lldpPortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_port_id", r.lldpPortId, "")
	}
	if r.lldpMgmtAddr != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "lldp_mgmt_addr", r.lldpMgmtAddr, "")
	}
	if r.band24Bandwith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_24_bandwith", r.band24Bandwith, "")
	}
	if r.band5Bandwith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_5_bandwith", r.band5Bandwith, "")
	}
	if r.band6Bandwith != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_6_bandwith", r.band6Bandwith, "")
	}
	if r.band24Channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_24_channel", r.band24Channel, "")
	}
	if r.band5Channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_5_channel", r.band5Channel, "")
	}
	if r.band6Channel != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "band_6_channel", r.band6Channel, "")
	}
	if r.eth0PortSpeed != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "eth0_port_speed", r.eth0PortSpeed, "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "")
	} else {
		var defaultValue int32 = 100
		r.limit = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	if r.duration != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "duration", r.duration, "")
	} else {
		var defaultValue string = "1d"
		r.duration = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ctx != nil {
		// API Key Authentication
		if auth, ok := r.ctx.Value(ContextAPIKeys).(map[string]APIKey); ok {
			if apiKey, ok := auth["apiToken"]; ok {
				var key string
				if apiKey.Prefix != "" {
					key = apiKey.Prefix + " " + apiKey.Key
				} else {
					key = apiKey.Key
				}
				localVarHeaderParams["Authorization"] = key
			}
		}
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v ResponseHttp400
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v ResponseHttp401
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v ResponseHttp403
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v ResponseHttp404
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v ResponseHttp429
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
